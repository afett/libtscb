/* -*- C++ -*-
 * (c) 2006 Helge Bahmann <hcb@chaoticmind.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1.
 * Refer to the file_event "COPYING" for details.
 */

#ifndef __TSCB_IOREADY_H
#define __TSCB_IOREADY_H

/**
	\page ioready_descr I/O readiness callbacks
	
	The class \ref tscb::ioready_service "ioready_service" defines the
	interface which receivers of I/O readiness callbacks can use to register
	themselves. Several concrete implementations of this interface exist and
	may be used on different platforms.
	
	
	\section ioready_registration Registration for events
	
	Interested receivers can register functions to be called when file
	descriptors are ready for IO at the
	\ref tscb::ioready_service "ioready_service" interface.
	Receivers can use the
	\ref tscb::ioready_service::watch "ioready_service::watch" functions
	for this purpose; they can be used in the following fashion:
	
	\code
		class IOHandler {
		public:
			void onDataReady(int fd, int event_mask) throw()
			{
				// process data
			}
			
			void finish(void) throw()
			{
				close(descriptor);
				delete this;
			}
			
			void register(tscb::ioready_service *service) throw(std::bad_alloc)
			{
				service->watch(boost::bind(&IOHandler::onDataReady, this, descriptor, _1),
					descriptor, tscb::EVMASK_INPUT);
			}
			
			int descriptor;
		};
	\endcode
	
	In the previous example, the <TT>onDataReady</TT> method of the
	corresponding object would be called whenever data is
	available on <TT>descriptor</TT>. The same approach also allows
	free-standing functions to be called:
	
	\code
		class IOContext;
		
		void onDataReady(IOContext *ctx, int fd, int event_mask) throw()
		{
			// process data
		}
		
		void finish(IOContext *ctx) throw()
		{
			delete IOContext;
		}
		
		void register(IOContext *ctx, int fd, tscb::ioready_service *service)
			throw(std::bad_alloc)
		{
			service->watch(boost::bind(&onDataReady, ctx, fd, _1),
				fd, tscb::EVMASK_INPUT);
		}
	\endcode
	
	Like in the previous example, the function <TT>onDataReady</TT> will
	be called whenever data is available on the file descriptor. Note that
	it is generally advisable to use some sort of "smart pointer" to convey
	context data to the called function, e.g.:
	
	\code
		class IOHandler {
		public:
			void onDataReady(int fd, int event_mask) throw()
			{
				// process data
			}
			
			void finish(void) throw()
			{
				close(descriptor);
				delete this;
			}
			
			void register(tscb::ioready_service *service) throw(std::bad_alloc)
			{
				service->watch(boost::bind(&IOHandler::onDataReady,
					boost::intrusive_ptr<IOHandler>(this), descriptor, _1),
					descriptor, tscb::EVMASK_INPUT);
			}
			
			int descriptor;
			int reference_count;
		};
		static inline void intrusive_ptr_add_ref(IOHandler *e) {...}
		static inline void intrusive_ptr_release(IOHandler *e) {...}
	\endcode
	
	Using this mechanism, the target object will be retained for as long
	as the function object is callable. The function object will be destroyed
	"soon after" cancelling the callback (see next section).
	
	\section ioready_callback_cookies Callback link handles for ioready callbacks
	
	The \ref tscb::ioready_service::watch "ioready_service::watch" functions
	return a reference to a callback link object that represents the
	connection between the callback service provider and the receiver. The
	return value can be stored by the caller:
	
	\code
		tscb::ioready_callback link;
		link=service->watch(boost::bind(&IOHandler::onDataReady, this, descriptor, _1),
			descriptor, tscb::EVMASK_INPUT);
	\endcode
	
	The link object can later be used for two purposes: 1. Cancel the
	callback:
	
	\code
		link->cancel();
	\endcode
	
	The function will no longer be invoked afterwards; the function
	object along with bound parameters will be destroyed subsequently
	(but not necessarily immediately, e.g. if there are pending calls
	from other threads).
	
	or 2. modify the event mask:
	
	\code
		link->modify(tscb::EVMASK_INPUT | tscb::EVMASK_OUTPUT);
	\endcode
	
	In this case, the callback will subsequently be invoked whenever the
	descriptor is in a state as indicated by the new event mask. The
	event mask may legally be zero, effectively temporarily disabling
	the callback.
	
	\section ioready_dispatcher_descr ioready dispatchers
	
	Free-standing implementations of the \ref tscb::ioready_service
	"ioready_service" interface derive from the \ref tscb::ioready_dispatcher
	"ioready_dispatcher" interface. Operating system-dependent mechanisms are
	used to query the state information of watched file descriptors.
	Specifically, the following methods are supported:
	
	<UL>
		<LI>
			Using the <TT>select</TT> system call:
			\ref tscb::ioready_dispatcher_select "ioready_dispatcher_select"
			(available all Posix systems)
		</LI>
		<LI>
			Using the <TT>poll</TT> system call:
			\ref tscb::ioready_dispatcher_poll "ioready_dispatcher_poll"
			(available most Posix systems)
		</LI>
		<LI>
			Using the <TT>epoll</TT> family of system calls:
			\ref tscb::ioready_dispatcher_epoll "ioready_dispatcher_epoll"
			(available on Linux systems)
		</LI>
		<LI>
			Using the <TT>kqueue</TT> family of system calls:
			\ref tscb::ioready_dispatcher_kqueue "ioready_dispatcher_kqueue"
			(available on BSD and derived systems)
		</LI>
	</UL>
	
	The \ref tscb::ioready_dispatcher "ioready_dispatcher" interface adds two
	methods in addition to those inherited from \ref tscb::ioready_service
	"ioready_service". The first method,
	\ref tscb::ioready_dispatcher::dispatch "ioready_dispatcher::dispatch",
	drives the dispatching mechanism and invokes the callbacks registered
	previously (see section \ref ioready_registration):
	
	\code
		tscb::ioready_dispatcher *dispatcher;
		...
		long long timeout=1000;
		
		while(true) dispatcher->dispatch(&timeout, 16);
	\endcode
	
	(Refer to \ref tscb::ioready_dispatcher::dispatch
	"ioready_dispatcher::dispatch" for a full description
	of the function). Like in the example above, at least one thread
	must periodically call \ref tscb::ioready_dispatcher::dispatch
	"ioready_dispatcher::dispatch";
	the function will check the registered receivers and process pending
	IO readiness callbacks.
	
	The second method, \ref tscb::ioready_dispatcher::get_eventflag
	"ioready_dispatcher::get_eventflag",
	allows to obtain a reference to an event flag associated with
	the dispatcher:
	
	\code
		tscb::ioready_dispatcher *dispatcher;
		...
		tscb::eventflag flag=dispatcher->get_eventflag();
	\endcode
	
	Raising the event flag will interrupt a timeout waiting for events
	to dispatch:
	
	\code
		tscb::eventflag flag;
		...
		flag->set();
	\endcode
	
	A thread currently in \ref tscb::ioready_dispatcher::dispatch
	"ioready_dispatcher::dispatch" would stop waiting
	for events and return prematurely. This is most useful in conjunction
	with timer queues (see the example at the end
	of section \ref timerqueue_dispatcher_descr).
	
	Please note:
	
	<UL>
		<LI>
			the eventflag is associated with the <I>dispatcher</I> and not
			one particular <I>thread</I> entering
			\ref tscb::ioready_dispatcher::dispatch
			"ioready_dispatcher::dispatch";
		</LI>
		<LI>
			depending on the implementation, raising the flag may
			cause one, many, or all threads currently in
			\ref tscb::ioready_dispatcher::dispatch "ioready_dispatcher::dispatch"
			to return prematurely.
		</LI>
		<LI>
			before returning, the event flag will be cleared
		</LI>
	</UL>
*/

#include <boost/function.hpp>
#include <boost/date_time/posix_time/posix_time_types.hpp>

#include <tscb/eventflag>
#include <tscb/signal>

namespace tscb {
	
	class ioready_service;
	class ioready_callback;
	
	/**
		\brief Input event mask
		
		Set this bit if you are interested for "input data ready" events
		on a descriptor; see
		\ref tscb::ioready_service::watch "ioready_service::watch".
	*/
	const int EVMASK_INPUT=1;
	/**
		\brief Output event mask
		
		Set this bit if you are interested for "output data ready" events
		on a descriptor; see
		\ref tscb::ioready_service::watch "ioready_service::watch".
	*/
	const int EVMASK_OUTPUT=2;
	/**
		\brief Hangup event mask
		
		Set this bit if you are interested for "connection closed" events
		on a descriptor; see
		\ref tscb::ioready_service::watch "ioready_service::watch".
	*/
	const int EVMASK_HANGUP=4;
	
	/**
		\brief callback link for I/O readiness events on file descriptors
		
		This class represents a link that has been established by registering
		a callback for I/O readiness events on file (or socket) descriptor
		events (see \ref tscb::ioready_service). Like its base class,
		\ref tscb::abstract_callback, it supports cancellation, but additionally
		it also allows to dynamically change the event notification mask
		(which is much more efficient than to cancel the previous callback and
		register a new one).
	*/
	class ioready_callback : public abstract_callback {
	public:
		/** \internal \brief Instantiate ioready callback link */
		inline ioready_callback(const boost::function<void (int)> &_target,
			int _fd, int _event_mask) throw()
			: target(_target), fd(_fd), event_mask(_event_mask)
		{}
		virtual ~ioready_callback(void) throw();
		
		virtual void disconnect(void) throw();
		
		/** \internal \brief Destroy function object after completing cancellation */
		inline void cancelled(void) throw() {target=0;}
		/**
			\brief modify the mask of events the receiver is interested in
			
			\param new_event_mask Mask of events the caller is interested in
			
			This replaces the previous event mask with anew mask; 
			subsequently callbacks will only be generated for events matching
			this mask.
			
			This operation is asynchronous, like all other methods. This
			means that it is still possible for callbacks to be generated
			for events that match the previous mask, but not the new one.
			
			The precise guarantee is: At most one event matching the
			previous event mask may be generated for each thread that
			is allowed to dispatch events for this callback.
		*/
		void modify(int new_event_mask) throw();
		
		virtual bool connected(void) const throw();
		
		/** \internal \brief Function object to call */
		boost::function<void(int)> target;
		/** \internal \brief File descriptor to watch */
		int fd;
		/** \internal \brief Events to watch file descriptor for */
		int event_mask;
		
		/** \internal \brief Next active element */
		ioready_callback *active_next;
		/** \internal \brief Previous element (active or to be removed) */
		ioready_callback *prev;
		/** \internal \brief Next element (active or to be removed) */
		ioready_callback *next;
		/** \internal \brief Next element scheduled for deferred cancellation */
		ioready_callback *inactive_next;
		/** \internal \brief ioready_service this element is linked to */
		ioready_service *service;
		/** \internal \brief Protect against concurrent cancellation */
		mutex cancellation_mutex;
	};
	
	/** \cond NEVER -- ignored by doxygen */
	static inline void intrusive_ptr_add_ref(ioready_callback *t) throw()
	{
		t->pin();
	}
	
	static inline void intrusive_ptr_release(ioready_callback *t) throw()
	{
		t->release();
	}
	/** \endcond */
	
	/**
		\brief IO readiness callback link
	*/
	class ioready_connection {
	public:
		inline ioready_connection(ioready_callback *_callback=0, bool add_ref=true) throw() : callback(_callback)
		{if (callback && add_ref) callback->pin();}
		
		inline ~ioready_connection(void) throw()
		{if (callback) callback->release();}
		
		template<typename ConnectionType>
		inline ioready_connection(const ConnectionType &conn) throw()
		{callback=conn.callback; if (callback) callback->pin();}
		
		inline ioready_connection(const ioready_connection &conn) throw()
		{callback=conn.callback; if (callback) callback->pin();}
		
		template<typename ConnectionType>
		inline ioready_connection &operator=(const ConnectionType &conn) throw()
		{callback=conn.callback; if (callback) callback->pin(); return *this;}
		
		inline ioready_connection &operator=(const ioready_connection &conn) throw()
		{callback=conn.callback; if (callback) callback->pin(); return *this;}
		
		inline void disconnect(void) throw()
		{if (callback) {callback->disconnect(); callback->release(); callback=0;}}
		
		inline void modify(int new_event_mask) throw() {callback->modify(new_event_mask);}
		
		inline bool connected(void) const throw()
		{return callback && callback->connected();}
		
		#ifdef __GXX_EXPERIMENTAL_CXX0X__
		template<typename ConnectionType>
		inline ioready_connection(ConnectionType && conn) throw()
		{callback=conn.callback; conn.callback=0;}
		
		template<typename ConnectionType>
		inline ioready_connection &operator=(ConnectionType && conn) throw()
		{callback=conn.callback; conn.callback=0; return *this;}
		#endif
		
	private:
		ioready_callback *callback;
	};
	
	/**
		\brief Registration for IO readiness events
		
		This class provides the registration interface for IO readiness
		callbacks. Receivers can use the \ref watch methods
		of this class to indicate their interest in readiness events
		on a specific file descriptor. See section \ref ioready_registration
		for examples on how to use this interface.
	*/
	class ioready_service {
	public:
		virtual ~ioready_service(void) throw();
		
		/**
			\brief register callback for file event
			
			\param function
				Function to be called in case of readiness for IO
			\param fd
				The file descriptor which should be monitored for events
			\param event_mask
				Set of events for which notification should be delivered
			\return
				Link object
			
			This function requests callbacks for IO readiness on a file
			descriptor (on Unix systems the objects for which events can be
			delivered include pipes, sockets, terminal lines, and a number of
			special device files).
			
			The event_mask indicates what events the callee
			is interested in; it is a bitwise "or" of one of the
			following constants:
			
			<UL>
				<LI>
					<TT>tscb::EVMASK_INPUT</TT>: descriptor is ready
					for reading
				</LI>
				<LI>
					<TT>tscb::EVMASK_OUTPUT</TT>: descriptor is ready
					for writing
				</LI>
			</UL>
			
			The passed function object will be called with a parameter
			indicating the set of events that have occurred. The returned
			link object may be used to modify the set of watched events
			or cancel the callback.
		*/
		ioready_connection
		watch(const boost::function<void(int)> &function, int fd, int event_mask) throw(std::bad_alloc)
		{
			ioready_callback *link=new ioready_callback(function, fd, event_mask);
			register_ioready_callback(link);
			return ioready_connection(link);
		}
		
		/* internal functions; actual implementation of the file event
		callback mechanism */
		friend class ioready_callback;
		/** \internal \brief Register callback link */
		virtual void register_ioready_callback(ioready_callback *l)
			throw(std::bad_alloc)=0;
		/** \internal \brief Unregister callback link */
		virtual void unregister_ioready_callback(ioready_callback *e)
			throw()=0;
		/** \internal \brief Update event set */
		virtual void modify_ioready_callback(ioready_callback *e, int event_mask)
			throw()=0;
	};
	
	/** \cond NEVER -- internal class, ignored by doxygen */
	class ioready_callback_table {
	public:
		ioready_callback_table(size_t initial=32) throw(std::bad_alloc);
		~ioready_callback_table(void) throw();
		
		ioready_callback *lookup_first_callback(int fd);
		void insert(ioready_callback *link) throw(std::bad_alloc);
		
		inline bool chain_empty(size_t fd) const throw()
		{
			if (fd>=table->size) return true;
			else return table->chains[fd].active==0;
		}
		
		void *get_closure(int fd) throw();
		void set_closure(int fd, void *closure) throw(std::bad_alloc);
		void remove(ioready_callback *link) throw();
		ioready_callback *synchronize(void) throw();
		
		void cancel_all(void) throw();
		
	protected:
		
		class ioready_callback_chain {
		public:
			ioready_callback *active;
			ioready_callback *first, *last;
			void *closure;
		};
		
		class chain_table {
		public:
			chain_table(size_t initial) throw(std::bad_alloc);
			~chain_table(void) throw();
			size_t size, max;
			ioready_callback_chain *chains;
			
			chain_table *old;
		};
		
		ioready_callback *inactive;
		
		chain_table *table;
		void grow(size_t new_size) throw(std::bad_alloc);
		void ensure_size(size_t min_size) throw(std::bad_alloc);
	};
	
	/** \endcond NEVER internal class */
	/* implementation */
	
	/**
		\brief Dispatcher for IO readiness events
		
		This class provides the interface for free-standing
		IO readiness callback dispatchers; it is implemented by several
		classes that use operating system-specific methods for collecting
		the required information.
	*/
	class ioready_dispatcher : public ioready_service {
	public:
		virtual ~ioready_dispatcher(void) throw();
		
		/**
			\brief Dispatch a number of pending events
			
			\param timeout
				Timeout, or a NULL pointer
			\param max
				Maximum number of events to be processed
			
			Check state of all registered file descriptors and process
			registered callback functions.
			
			All pending events are processed up to the indicated maximum
			number of events; unprocessed events will be processed in further
			calls to \ref dispatch.
			
			The function will return indicating the number of events processed
			as soon as one the following conditions becomes true:
			<UL>
				<LI>
					at least one (and up to <TT>max</TT>) number of events
					have been processed
				</LI>
				<LI>
					no event was processed, but a timeout has occured waiting
					for events, as indicated by the <TT>timeout</TT> parameter;
					if <TT>timeout</TT> is a NULL pointer, \ref dispatch
					will wait indefinitely
				</LI>
				<LI>
					the \ref tscb::eventflag associated with the dispatcher
					has been raised (see \ref get_eventflag)
				</LI>
				<LI>
					registration: depending on the dispatcher implementation
					dispatching may be interrupted if callbacks
					are registered, modified or cancelled by another
					thread
				</LI>
			</UL>
			
			The function is generally reentrant, multiple threads
			can enter the dispatching loop simultaneously. However depending
			on the concrete dispatcher implementation the behaviour
			may not be terribly useful, as some dispatchers will attempt
			to dispatch the same event in multiple threads.
		*/
		virtual int dispatch(const boost::posix_time::time_duration *timeout,
			int max=2147483647L)
			throw()=0;
		
		/**
			\brief Event flag to wake up prematurely
			
			Returns a pointer to an event flag that allows interrupting
			waiting for the timeout specified as argument to \ref dispatch.
			Setting this flag (possibly from another thread) via \ref
			tscb::eventflag::set will cause
			the \ref dispatch function to return immediately. The flag
			will be cleared by the \ref dispatch function before returning.
			
			This functionality is mostly useful in multi-threaded
			programs to interrupt one dispatcher, e.g. because a
			timeout has to be shortened.
			
			The \ref tscb::eventflag returned is inseparably associated
			with the dispatcher; its lifetime is implicitly determined
			by the lifetime of the dispatcher object, and it must
			not be destroyed by the caller. Furthermore, multiple calls
			to \ref get_eventflag will always return the same event
			flag (instead of creating a new one)
		*/
		virtual eventflag *get_eventflag(void)
			throw(std::bad_alloc, std::runtime_error)=0;
		
		/**
			\brief Instantiate ioready_dispatcher
			
			Instantiates an object of type \ref ioready_dispatcher,
			using the dispatching mechanism most suitable for the
			current platform. Alias for
			\ref create_ioready_dispatcher
		*/
		static
		ioready_dispatcher *
		create(void) throw(std::bad_alloc, std::runtime_error);
		
	};
	
	/**
		\brief Create dispatcher for ioready events
		
		Select an \ref tscb::ioready_dispatcher "ioready_dispatcher"
		implementation and instantiate dispatcher class. The function
		will select the "best" dispatcher available on the current
		platform dynamically; the order of preference is:
		
		<UL>
			<LI>\ref tscb::ioready_dispatcher_kqueue "ioready_dispatcher_kqueue"</LI>
			<LI>\ref tscb::ioready_dispatcher_epoll "ioready_dispatcher_epoll"</LI>
			<LI>\ref tscb::ioready_dispatcher_poll "ioready_dispatcher_poll"</LI>
			<LI>\ref tscb::ioready_dispatcher_select "ioready_dispatcher_select"</LI>
		</UL>
	*/
	ioready_dispatcher *
	create_ioready_dispatcher(void) throw(std::bad_alloc, std::runtime_error);
	
}

#endif
