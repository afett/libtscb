/* -*- C++ -*-
 * (c) 2006 Helge Bahmann <hcb@chaoticmind.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1.
 * Refer to the file "COPYING" for details.
 */

#ifndef __TSCB_ATOMIC_AMD64_H
#define __TSCB_ATOMIC_AMD64_H

namespace tscb {
	
	/** \cond NEVER */
	
	class atomic {
	public:
		inline atomic(int initial=0) : value(initial) {}
		inline void operator++(void) {
			__asm__ __volatile__("lock ; incl %0" : "=m" (value) : "m" (value));
		}
		inline void operator++(int) {
			__asm__ __volatile__("lock ; incl %0" : "=m" (value) : "m" (value));
		}
		inline bool operator--(void) {
			char c;
			__asm__ __volatile__("lock ; decl %0; sete %1" : "=m" (value), "=qm" (c) : "m" (value));
			return !(bool)c;
		}
		inline void operator--(int) {
			__asm__ __volatile__("lock ; decl %0" : "=m" (value) : "m" (value));
		}
		inline bool inc_if_not_zero(void) {
			int oldval, verify, newval;
			__asm__ __volatile__(
				"1: movl %3, %0\n"
				"test %0, %0\n"
				"lea 1(%0), %2\n"
				"movl %0, %1\n"
				"je 2f\n"
				"lock cmpxchgl %2, %3\n"
				"cmp %0, %1\n"
				"jne 1b\n"
				"2:"
				: "=&a" (oldval), "=&r" (verify), "=&DS" (newval)
				: "m" (value)
				: "cc"
			);
			return oldval;
		}
		inline int cmpxchg(int oldvalue, int newvalue)
		{
			int retval;
			__asm__ __volatile__(
				"lock cmpxchgl %1, %2\n"
				: "=a" (retval)
				: "q" (newvalue), "m" (value), "a" (oldvalue)
			);
			return retval;
		}
		inline operator long(void) const {return value;}
		inline bool operator==(long v) const {return value==v;}
		inline bool operator==(int v) const {return value==v;}
		inline void operator=(long n) {value=n;}
	private:
		volatile int value;
	};
	
	inline void memory_barrier(void)
	{
		// hm... as far as I understand AMD64 memory model
		// is sequentially consistent; at least I have not been
		// able to view any reordered reads/writes in repeated tests
		//__asm__ __volatile__ ("mfence" ::: "memory");
	}
	
	inline void data_dependence_memory_barrier(void)
	{
	}
	
	/** \endcond */
}

#endif
