/* -*- C++ -*-
 * (c) 2006 Helge Bahmann <hcb@chaoticmind.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1.
 * Refer to the file "COPYING" for details.
 */

#ifndef __TSCB_CALLBACK_H
#define __TSCB_CALLBACK_H

/**
	\page callback_descr Generic callbacks
	
	The \ref tscb::callback_chain "callback_chain" ... template class provides
	a generic callback mechanism. It allows one object
	(the "sender") to notify an arbitray number of other objects
	(the "receivers") of events by calling specified functions.
	
	The template can be instantiated with at least one and up
	to six template arguments; they allow to customize the signature of the
	callback functions to match the intended use case.
	
	\section callback_declaration Declaration of callback chains
	
	Callback chains are declared as global or member variables; the
	template arguments define the arguments passed with every callback
	invocation (and thus the signature of the expected callback	functions):
	
	\code
		class MyClass {
		public:
			// will report old and new value to callbacks
			tscb::callback_chain<int, int> onValueChange;
			
			void setValue(int newval);
		private:
			int value;
		}
	\endcode
	
	\section callback_issue Issuing callbacks
	
	Callback chain objects (as declared in the previous example) provide
	an overloaded () operator which will call all callback functions
	registered with this callback chain:
	
	\code
		void MyClass::setValue(int newval)
		{
			int oldval=value;
			value=newval;
			// notify all registered callbacks
			onValueChange(oldval, newval);
		}
	\endcode
	
	The overloaded () operator expects exactly the number and type
	of arguments as were used when the callback chain was declared.
	
	\section callback_register Registration for callbacks
	
	Callback chains provide the \ref tscb::callback_chain::connect "connect"
	template member functions to allow receivers to add a callback
	function to the chain. They can be used in the following fashion:
	
	\code
		class MyObserver {
		public:
			MyObserver(MyClass *c)
			{
				c->onValueChange.connect<MyObserver, &MyObserver::notify_change, &MyObserver::finish>
					(this);
			}
		protected:
			void notify_change(int oldval, int newval)
			{
				printf("Value changed from %d to %d!\n", oldval, newval);
			}
			void finish(void)
			{
				delete this;
			}
		};
	\endcode
	
	In the previous example, the <TT>notify_change</TT> method of the
	corresponding <TT>MyObserver</TT> object would be called
	whenever the callback chain is being activated
	(see section \ref callback_issue above). The <TT>finish</TT>
	method will be called after the callback has been
	cancelled (see section \ref callback_cookies below).
	
	Another variant of the \ref tscb::callback_chain::connect "connect"
	method allows free-standing functions to be called:
	
	\code
		char *msg="Incredible!";
		
		void notify_change(char *ctx, int oldval, int newval)
		{
			printf("%s Value changed from %d to %d!\n", ctx, oldval, newval);
		}
		
		void finish(char *ctx)
		{
			// nothing to do
		}
		
		int main(void)
		{
			MyObject obj;
			obj.onValueChange.connect<char *, &notify_change, &finish>(msg);
			obj.setValue(42);
		}
	\endcode
	
	Like in the previous example, the function <TT>notify_change</TT>
	will be called whenever the callback chain is being activated,
	and <TT>finish</TT> will be called after the callback has been cancelled.
	
	The first template parameter to 
	\ref tscb::callback_chain::connect "connect"
	allows to pass arbitrary data structures as contexts in a type-safe
	manner. Usually the contex object will be a pointer to a data structure
	containing the required context data. It is possible to pass arbitrary
	data structures if desired, but the folliwng restrictions have to be
	kept in mind:
	
	<UL>
		<LI>
			The <TT>Context</TT> data type must be copy-constructible
		</LI>
		<LI>
			The context object will be copied on creation of the callback link
		</LI>
		<LI>
			The context object will be destroyed when the link is
			destroyed
		</LI>
	</UL>
	
	\section callback_cookies Callback link handles
	
	The
	\ref tscb::callback_chain::connect "connect"
	return a reference to a callback link object that represents the
	connection between the callback service provider and the receiver. The
	return value can be stored by the caller:
	
	\code
		tscb::callback link;
		link=c->onValueChange.connect<MyObserver, &MyObserver::notify_change, &MyObserver::finish>
			(this);
	\endcode
	
	The link object can later be used to cancel the
	callback:
	
	\code
		link->cancel();
	\endcode
	
	The callback function will not be invoked subsequently; the registered
	<TT>release</TT> function (third template parameter to
	\ref tscb::callback_chain::connect "connect") will be called
	exactly once as soon as it is guaranteed that the callback function cannot
	be called again.
	
	\section Performance
	
	The synchronization mechanism used to protect the integrity of the
	callback chains is \ref tscb::deferred_rwlock. Thus overhead
	incurred by the synchronization mechanism has to be paid for callback
	chains as well.
	
	The implementation assumes that callback processing (in contrast
	to callback registration/cancellation) is the fast path
	and has been optimized to this end. The performance characteristics
	are thus:
	
	<UL>
		<LI>
			process callbacks: O(number_of_registered_callbacks)
		</LI>
		<LI>
			cancel callback: O(1) (if there is no contention, i.e.
			the chain is not being traversed while cancelling callbacks)
		</LI>
		<LI>
			cancel callback: O(numer_of_cancels^2) (if there is contention,
			i.e. the chain is being traversed while cancelling callbacks)
		</LI>
	</UL>
	
	Some measurement were made to estimate the number of clock cycles
	it takes to call an empty function which takes a single integer parameter:
	
	<TABLE>
		<TR><TH>call type</TH><TH>Motorola PPC7455</TH><TH>Intel Pentium III SSE</TH><TH>AMD Athlon</TH></TR>
		<TR><TD>direct method call (non-virtual)</TD><TD>8</TD><TD>8</TD><TD>7</TD></TR>
		<TR><TD>indirect method call (non-virtual)</TD><TD>15</TD><TD>12</TD><TD>10</TD></TR>
		<TR><TD>callback chain, 1 callback</TD><TD>131</TD><TD>151</TD><TD>99</TD></TR>
		<TR><TD>callback chain, 2 callbacks</TD><TD>166</TD><TD>180</TD><TD>122</TD></TR>
		<TR><TD>callback chain, 3 callbacks</TD><TD>192</TD><TD>207</TD><TD>142</TD></TR>
	</TABLE>
*/

#include <stdexcept>

#include <tscb/thread>
#include <tscb/ref>
#include <tscb/deferred>
#include <tscb/compiler>

namespace tscb {
	
	/**
		\brief Generic callback link
		
		This object represents the link between a sender/caller, from
		which notification is requested, to a reciever/callee, to which
		notification is to be delivered. It is an abstract base class
		for all different kinds of links established through the various
		notification interfaces (callback_chains, file or timer events).
		
		Link objects are reference-counted entities, and as such have
		to be treated according to the rules outlined \ref ref_descr "here".
	*/
	class callback_link {
	public:
		inline callback_link(void) throw() : refcount(1) {}
		virtual ~callback_link(void) throw();
		/**
			\brief Break the link
			
			Calling this function will break the notification link. It will
			usually cease notifications to be delivered some time after this
			function has returned. The exact semantic guarantee is:
			
			<UL>
				<LI>
					no notification will be delivered within the same thread
					that has called \ref cancel after \ref cancel has
					returned (i.e. within the same thread, \ref cancel
					is synchronous)
				</LI>
				<LI>
					notifications in other threads may be delivered after
					\ref cancel has returned in one thread, but only
					for events that occured before \ref cancel has returned
					(i.e. for other threads, cancellation is asynchronous).
				</LI>
			</UL>
			
			The weak synchronicity guarantee allows implementations that
			provide excellent concurrency. Furthermore it allows
			\ref cancel to be called from arbitrary contexts: from within
			the callback to be cancelled, from different threads etc. It
			is guaranteed to be deadlock free.
			
		*/
		virtual void cancel(void) throw()=0;
		
		/**
			\brief Confirm cancellation of callback
			
			This function is called by the sending side of a callback
			in reaction to a call to \ref cancel, when it can be proven
			that the callback cannot be triggered any longer. it <I>must
			not</I> be called by the receiving side of the callback.
			
			Implementations will override this method to perform whatever
			cleanup operation is required after the callback has been
			cancelled; for example this can be used to release a reference
			to the target object.
		*/
		virtual void cancelled(void) throw();
		
		/* reference counting stuff */
		inline void pin(void) throw() {refcount++;}
		inline void release(void) throw() {if (!--refcount) delete this;}
		
	private:
#ifdef _LIBTSCB_CALLBACK_UNITTESTS
	public:
#endif
		atomic refcount;
	};
	
	/**
		\brief Generic callback link.
		
		Every other callback link implemented in this library can be
		downcast to this type.
	*/
	typedef ref<callback_link> callback;
	
	template<typename link>
	class callback_list {
	public:
		callback_list(void) throw()
			: active(0), first(0), last(0), deferred_cancel(0)
		{}
		~callback_list(void) throw()
		{
			/* there is no point in locking here... if the object
			is destroyed and anyone is trying to add a callback
			at this moment we are hosed anyways */
			
			/* but we can protect against anyone *removing*
			callbacks concurrently */
			
			while(guard.read_lock()) synchronize();
			while (active) active->cancel();
			if (guard.read_unlock()) {
				/* the above cancel operations will cause synchronization
				to be performed at the next possible point in time; if
				there is no concurrent cancellation, this is now */
				synchronize();
			} else {
				/* this can only happen if some callback link was
				cancelled while this object is being destroyed; in
				that case we have to suspend the thread that is destroying
				the object until we are certain that synchronization has
				been performed */
				
				guard.write_lock_sync();
				synchronize();
				
				/* note that synchronize implicitly calls sync_finished,
				which is equivalent to write_unlock_sync for deferrable_rwlocks */
			}
		}
		
		void push_back(link *l) throw()
		{
			l->registration_mutex.lock();
			l->pin();
			bool sync=guard.write_lock_async();
			
			l->next=0;
			l->prev=last;
			
			l->active_next=0;
			
			/* prevent traversal of chain from seeing "incomplete" entries */
			memory_barrier();
			
			/* add element to active list; find all elements that have been removed
			from the full list and thus terminate the active list; point them to
			the newly-added element */
			
			link *tmp=last;
			while(true) {
				if (!tmp) {
					if (!active) active=l;
					break;
				}
				if (tmp->active_next) break;
				tmp->active_next=l;
				tmp=tmp->prev;
			}
			
			/* insert into list of all elements*/
			if (last) last->next=l;
			else first=l;
			last=l;
			
			l->chain=this;
			
			l->registration_mutex.unlock();
			
			if (sync) synchronize();
			else guard.write_unlock_async();
		}
		
		void remove(link *l) throw()
		{
			bool sync=guard.write_lock_async();
			if (l->chain==this) {
				/* remove element from active list; we have to make
				sure that all elements that pointed to "us" within
				the active chain now point to the following element,
				so this element is skipped from within the active chain */
				
				link *tmp=l->prev;
				while(true) {
					if (!tmp) {
						if (active==l) active=l->active_next;
						break;
					}
					if (tmp->active_next!=l) break;
					tmp->active_next=l->active_next;
					tmp=tmp->prev;
				}
				
				/* put on list of elements marked for deferred cancellation */
				l->deferred_cancel_next=deferred_cancel;
				deferred_cancel=l;
				
				/* remove pointer to chain, so a second call to ->cancel()
				will do nothing */
				l->chain=0;
			}
			
			l->registration_mutex.unlock();
			
			if (sync) synchronize();
			else guard.write_unlock_async();
		}
		
		void synchronize(void) throw()
		{
			link *do_cancel=deferred_cancel;
			
			/* first, "repair" the list structure by "correcting" all prev
			pointers */
			while(do_cancel) {
				/* we can now safely remove the elements from the list */
				if (do_cancel->prev) do_cancel->prev->next=do_cancel->next;
				else first=do_cancel->next;
				if (do_cancel->next) do_cancel->next->prev=do_cancel->prev;
				else last=do_cancel->prev;
				
				do_cancel=do_cancel->deferred_cancel_next;
			}
			
			/* now swap pointers while still under the lock; this is
			necessary to make sure that the destructor for each
			callback link object is called exactly once */
			do_cancel=deferred_cancel;
			deferred_cancel=0;
			guard.sync_finished();
			
			/* now we can release the callbacks, as we are sure that no one
			can "see" them anymore; the lock is dropped so side-effest
			of finalizing the links cannot cause deadlocks */
			
			while(do_cancel) {
				link *tmp=do_cancel->deferred_cancel_next;
				do_cancel->cancelled();
				do_cancel->release();
				do_cancel=tmp;
			}
		}
		
		inline void read_lock(void) throw()
		{
			while(guard.read_lock()) synchronize();
		}
		
		inline void read_unlock(void) throw()
		{
			if (guard.read_unlock()) synchronize();
		}
	protected:
		/* singly-linked list of active elements */
		link *active;
		
		/* thread synchronization */
		deferrable_rwlock guard;
		
		/* list of all elements in the chain, whether active or not */
		link *first, *last;
		
		/* singly-linked list of elements that have been removed from
		the active list, but are not yet removed from the full list
		and not been discarded yet*/
		link *deferred_cancel;
	};
	
	template<typename Arg1>
	class callback_chain1;
	template<typename Arg1, typename Arg2>
	class callback_chain2;
	template<typename Arg1, typename Arg2, typename Arg3>
	class callback_chain3;
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4>
	class callback_chain4;
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
	class callback_chain5;
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
	class callback_chain6;
	
	/**************************************************************************/
	
	/**
		\brief Link to callback function with 1 argument
	*/
	template<typename Arg1>
	class function_callback_link1 : public callback_link {
	public:
		function_callback_link1(void) throw()
			: active_next(0), prev(0), next(0), chain(0)
		{}
		virtual ~function_callback_link1(void) throw()
		{}
		virtual void operator()(Arg1 arg1) throw()=0;
		virtual void cancel(void) throw()
		{
			registration_mutex.lock();
			if (chain) chain->remove(this);
			else registration_mutex.unlock();
		}
		
		function_callback_link1 *active_next;
		function_callback_link1 *prev, *next;
		function_callback_link1 *deferred_cancel_next;
		
		callback_list<function_callback_link1> *chain;
		
		mutex registration_mutex;
	};
	
	/* \cond NEVER */
	
	template<typename Arg1, typename Context, void (*function)(Context, Arg1 arg1), void (*_release)(Context)>
	class function_link1 : public function_callback_link1<Arg1> {
	public:
		inline function_link1(Context _context) throw()
			: context(_context)
		{}
		virtual ~function_link1(void) throw() {}
		virtual void operator()(Arg1 arg1) throw()
		{(*function)(context, arg1);}
	private:
		Context context;
		virtual void cancelled(void) throw()
		{(*_release)(context);}
	};
	
	template<typename Arg1, typename Obj, void (Obj::*function)(Arg1 arg1), void (Obj::*_release)(void)>
	class obj_link1 : public function_callback_link1<Arg1> {
	public:
		inline obj_link1(Obj *instance ) throw()
			: i(instance)
		{}
		virtual ~obj_link1(void) throw() {}
		virtual void operator()(Arg1 arg1) throw()
		{(i->*function)(arg1);}
	private:
		Obj *i;
		virtual void cancelled(void) throw()
		{(i->*_release)();}
	};
	
	template<typename Arg1, typename Obj, void (Obj::*function)(Arg1 arg1)>
	class refobj_link1 : public function_callback_link1<Arg1> {
	public:
		inline refobj_link1(tscb::ref<Obj> instance ) throw()
			: i(tscb::ref_transfer<Obj>(instance))
		{}
		virtual ~refobj_link1(void) throw() {}
		virtual void operator()(Arg1 arg1) throw()
		{(i->*function)(arg1);}
	private:
		tscb::ref<Obj> i;
		virtual void cancelled(void) throw()
		{i=0;}
	};
	
	/* \endcond */
	
	/**
		\brief Chain of callback functions with 1 argument
		
		detail
	*/
	template<typename Arg1>
	class callback_chain1 : public callback_list<function_callback_link1<Arg1> > {
	public:
		typedef function_callback_link1<Arg1> link_type;
		typedef callback_list<link_type> parent_type;
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Context, void (*function)(Context, Arg1), void (*release)(Context)>
		ref_transfer<callback_link> connect(Context context) throw(std::bad_alloc)
		{
			link_type *l=
				new function_link1<Arg1, Context, function, release>(context);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Obj, void(Obj::*function)(Arg1), void(Obj::*release)(void)>
		ref_transfer<callback_link> connect(Obj *o) throw(std::bad_alloc)
		{
			link_type *l=
				new obj_link1<Arg1, Obj, function, release>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel".
			
			The target object muss support reference counting through
			->pin() and ->release() member functions; ->pin() will
			be used to acquire a reference to the target object; ->release()
			will be called after the callback has been cancelled.
		*/
		template<typename Obj, void(Obj::*function)(Arg1)>
		ref_transfer<callback_link> ref_connect(ref<Obj> o) throw(std::bad_alloc)
		{
			link_type *l=
				new refobj_link1<Arg1, Obj, function>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		inline void operator()(Arg1 arg1)
		{
			parent_type::read_lock();
			link_type *l=parent_type::active;
			while(l) {
				data_dependence_memory_barrier();
				(*l)(arg1);
				l=l->active_next;
			}
			parent_type::read_unlock();
		}
	};
	
	/**************************************************************************/
	
	/**
		\brief Link to callback function with 2 arguments
	*/
	template<typename Arg1, typename Arg2>
	class function_callback_link2 : public callback_link {
	public:
		function_callback_link2(void) throw()
			: active_next(0), prev(0), next(0), chain(0)
		{}
		virtual ~function_callback_link2(void) throw()
		{}
		virtual void operator()(Arg1 arg1, Arg2 arg2) throw()=0;
		virtual void cancel(void) throw()
		{
			registration_mutex.lock();
			if (chain) chain->remove(this);
			else registration_mutex.unlock();
		}
		
		function_callback_link2 *active_next;
		function_callback_link2 *prev, *next;
		function_callback_link2 *deferred_cancel_next;
		
		callback_list<function_callback_link2> *chain;
		
		mutex registration_mutex;
	};
	
	/** \cond NEVER */
	
	template<typename Arg1, typename Arg2,
	typename Context, void (*function)(Context, Arg1 arg1, Arg2 arg2), void (*_release)(Context)>
	class function_link2 : public function_callback_link2<Arg1, Arg2> {
	public:
		inline function_link2(Context _context) throw()
			: context(_context)
		{}
		virtual ~function_link2(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2) throw()
		{(*function)(context, arg1, arg2);}
	private:
		Context context;
		virtual void cancelled(void) throw()
		{(*_release)(context);}
	};
	
	template<typename Arg1, typename Arg2,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2), void (Obj::*_release)(void)>
	class obj_link2 : public function_callback_link2<Arg1, Arg2> {
	public:
		inline obj_link2(Obj *instance ) throw()
			: i(instance)
		{}
		virtual ~obj_link2(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2) throw()
		{(i->*function)(arg1, arg2);}
	private:
		Obj *i;
		virtual void cancelled(void) throw()
		{(i->*_release)();}
	};
	
	template<typename Arg1, typename Arg2,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2)>
	class refobj_link2 : public function_callback_link2<Arg1, Arg2> {
	public:
		inline refobj_link2(tscb::ref<Obj> instance ) throw()
			: i(tscb::ref_transfer<Obj>(instance))
		{}
		virtual ~refobj_link2(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2) throw()
		{(i->*function)(arg1, arg2);}
	private:
		tscb::ref<Obj> i;
		virtual void cancelled(void) throw()
		{i=0;}
	};
	
	/** \endcond */
	
	/**
		\brief Chain of callback functions with 2 arguments
	*/
	template<typename Arg1, typename Arg2>
	class callback_chain2 : public callback_list<function_callback_link2<Arg1, Arg2> > {
	public:
		typedef function_callback_link2<Arg1, Arg2> link_type;
		typedef callback_list<link_type> parent_type;
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Context, void (*function)(Context, Arg1, Arg2), void (*release)(Context)>
		ref_transfer<callback_link> connect(Context context) throw(std::bad_alloc)
		{
			link_type *l=
				new function_link2<Arg1, Arg2, Context, function, release>(context);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2), void(Obj::*release)(void)>
		ref_transfer<callback_link> connect(Obj *o) throw(std::bad_alloc)
		{
			link_type *l=
				new obj_link2<Arg1, Arg2, Obj, function, release>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel".
			
			The target object muss support reference counting through
			->pin() and ->release() member functions; ->pin() will
			be used to acquire a reference to the target object; ->release()
			will be called after the callback has been cancelled.
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2)>
		ref_transfer<callback_link> ref_connect(ref<Obj> o) throw(std::bad_alloc)
		{
			link_type *l=
				new refobj_link2<Arg1, Arg2, Obj, function>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		inline void operator()(Arg1 arg1, Arg2 arg2)
		{
			parent_type::read_lock();
			link_type *l=parent_type::active;
			while(l) {
				data_dependence_memory_barrier();
				(*l)(arg1, arg2);
				l=l->active_next;
			}
			parent_type::read_unlock();
		}
	};
	
	/**************************************************************************/
	
	/**
		\brief Link to callback function with 3 arguments
	*/
	template<typename Arg1, typename Arg2, typename Arg3>
	class function_callback_link3 : public callback_link {
	public:
		function_callback_link3(void) throw()
			: active_next(0), prev(0), next(0), chain(0)
		{}
		virtual ~function_callback_link3(void) throw()
		{}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3) throw()=0;
		virtual void cancel(void) throw()
		{
			registration_mutex.lock();
			if (chain) chain->remove(this);
			else registration_mutex.unlock();
		}
		
		function_callback_link3 *active_next;
		function_callback_link3 *prev, *next;
		function_callback_link3 *deferred_cancel_next;
		
		callback_list<function_callback_link3> *chain;
		
		mutex registration_mutex;
	};
	
	/** \cond NEVER */
	
	template<typename Arg1, typename Arg2, typename Arg3,
	typename Context, void (*function)(Context, Arg1 arg1, Arg2 arg2, Arg3 arg3), void (*_release)(Context)>
	class function_link3 : public function_callback_link3<Arg1, Arg2, Arg3> {
	public:
		inline function_link3(Context _context) throw()
			: context(_context)
		{}
		virtual ~function_link3(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3) throw()
		{(*function)(context, arg1, arg2, arg3);}
	private:
		Context context;
		virtual void cancelled(void) throw()
		{(*_release)(context);}
	};
	
	template<typename Arg1, typename Arg2, typename Arg3,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2, Arg3 arg3), void (Obj::*_release)(void)>
	class obj_link3 : public function_callback_link3<Arg1, Arg2, Arg3> {
	public:
		inline obj_link3(Obj *instance ) throw()
			: i(instance)
		{}
		virtual ~obj_link3(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3) throw()
		{(i->*function)(arg1, arg2, arg3);}
	private:
		Obj *i;
		virtual void cancelled(void) throw()
		{(i->*_release)();}
	};
	
	template<typename Arg1, typename Arg2, typename Arg3,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2, Arg3 arg3)>
	class refobj_link3 : public function_callback_link3<Arg1, Arg2, Arg3> {
	public:
		inline refobj_link3(tscb::ref<Obj> instance ) throw()
			: i(tscb::ref_transfer<Obj>(instance))
		{}
		virtual ~refobj_link3(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3) throw()
		{(i->*function)(arg1, arg2, arg3);}
	private:
		tscb::ref<Obj> i;
		virtual void cancelled(void) throw()
		{i=0;}
	};
	
	/** \endcond */
	
	/**
		\brief Chain of callback functions with 3 arguments
	*/
	template<typename Arg1, typename Arg2, typename Arg3>
	class callback_chain3 : public callback_list<function_callback_link3<Arg1, Arg2, Arg3> > {
	public:
		typedef function_callback_link3<Arg1, Arg2, Arg3> link_type;
		typedef callback_list<link_type> parent_type;
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Context, void (*function)(Context, Arg1, Arg2, Arg3), void (*release)(Context)>
		ref_transfer<callback_link> connect(Context context) throw(std::bad_alloc)
		{
			link_type *l=
				new function_link3<Arg1, Arg2, Arg3, Context, function, release>(context);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2, Arg3), void(Obj::*release)(void)>
		ref_transfer<callback_link> connect(Obj *o) throw(std::bad_alloc)
		{
			link_type *l=
				new obj_link3<Arg1, Arg2, Arg3, Obj, function, release>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel".
			
			The target object muss support reference counting through
			->pin() and ->release() member functions; ->pin() will
			be used to acquire a reference to the target object; ->release()
			will be called after the callback has been cancelled.
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2, Arg3)>
		ref_transfer<callback_link> ref_connect(ref<Obj> o) throw(std::bad_alloc)
		{
			link_type *l=
				new refobj_link3<Arg1, Arg2, Arg3, Obj, function>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		inline void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3)
		{
			parent_type::read_lock();
			link_type *l=parent_type::active;
			while(l) {
				data_dependence_memory_barrier();
				(*l)(arg1, arg2, arg3);
				l=l->active_next;
			}
			parent_type::read_unlock();
		}
	};
	
	/**************************************************************************/
	
	/**
		\brief Link to callback function with 4 arguments
	*/
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4>
	class function_callback_link4 : public callback_link {
	public:
		function_callback_link4(void) throw()
			: active_next(0), prev(0), next(0), chain(0)
		{}
		virtual ~function_callback_link4(void) throw()
		{}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) throw()=0;
		virtual void cancel(void) throw()
		{
			registration_mutex.lock();
			if (chain) chain->remove(this);
			else registration_mutex.unlock();
		}
		
		function_callback_link4 *active_next;
		function_callback_link4 *prev, *next;
		function_callback_link4 *deferred_cancel_next;
		
		callback_list<function_callback_link4> *chain;
		
		mutex registration_mutex;
	};
	
	/** \cond NEVER */
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4,
	typename Context, void (*function)(Context, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4), void (*_release)(Context)>
	class function_link4 : public function_callback_link4<Arg1, Arg2, Arg3, Arg4> {
	public:
		inline function_link4(Context _context) throw()
			: context(_context)
		{}
		virtual ~function_link4(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) throw()
		{(*function)(context, arg1, arg2, arg3, arg4);}
	private:
		Context context;
		virtual void cancelled(void) throw()
		{(*_release)(context);}
	};
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4), void (Obj::*_release)(void)>
	class obj_link4 : public function_callback_link4<Arg1, Arg2, Arg3, Arg4> {
	public:
		inline obj_link4(Obj *instance ) throw()
			: i(instance)
		{}
		virtual ~obj_link4(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) throw()
		{(i->*function)(arg1, arg2, arg3, arg4);}
	private:
		Obj *i;
		virtual void cancelled(void) throw()
		{(i->*_release)();}
	};
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)>
	class refobj_link4 : public function_callback_link4<Arg1, Arg2, Arg3, Arg4> {
	public:
		inline refobj_link4(tscb::ref<Obj> instance ) throw()
			: i(tscb::ref_transfer<Obj>(instance))
		{}
		virtual ~refobj_link4(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) throw()
		{(i->*function)(arg1, arg2, arg3, arg4);}
	private:
		tscb::ref<Obj> i;
		virtual void cancelled(void) throw()
		{i=0;}
	};
	
	/** \endcond */
	
	/**
		\brief Chain of callback functions with 4 arguments
	*/
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4>
	class callback_chain4 : public callback_list<function_callback_link4<Arg1, Arg2, Arg3, Arg4> > {
	public:
		typedef function_callback_link4<Arg1, Arg2, Arg3, Arg4> link_type;
		typedef callback_list<link_type> parent_type;
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Context, void (*function)(Context, Arg1, Arg2, Arg3, Arg4), void (*release)(Context)>
		ref_transfer<callback_link> connect(Context context) throw(std::bad_alloc)
		{
			link_type *l=
				new function_link4<Arg1, Arg2, Arg3, Arg4, Context, function, release>(context);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2, Arg3, Arg4), void(Obj::*release)(void)>
		ref_transfer<callback_link> connect(Obj *o) throw(std::bad_alloc)
		{
			link_type *l=
				new obj_link4<Arg1, Arg2, Arg3, Arg4, Obj, function, release>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel".
			
			The target object muss support reference counting through
			->pin() and ->release() member functions; ->pin() will
			be used to acquire a reference to the target object; ->release()
			will be called after the callback has been cancelled.
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2, Arg3, Arg4)>
		ref_transfer<callback_link> ref_connect(ref<Obj> o) throw(std::bad_alloc)
		{
			link_type *l=
				new refobj_link4<Arg1, Arg2, Arg3, Arg4, Obj, function>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		inline void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
		{
			parent_type::read_lock();
			link_type *l=parent_type::active;
			while(l) {
				data_dependence_memory_barrier();
				(*l)(arg1, arg2, arg3, arg4);
				l=l->active_next;
			}
			parent_type::read_unlock();
		}
	};
	
	/**************************************************************************/
	
	/**
		\brief Link to callback function with 5 arguments
	*/
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
	class function_callback_link5 : public callback_link {
	public:
		function_callback_link5(void) throw()
			: active_next(0), prev(0), next(0), chain(0)
		{}
		virtual ~function_callback_link5(void) throw()
		{}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) throw()=0;
		virtual void cancel(void) throw()
		{
			registration_mutex.lock();
			if (chain) chain->remove(this);
			else registration_mutex.unlock();
		}
		
		function_callback_link5 *active_next;
		function_callback_link5 *prev, *next;
		function_callback_link5 *deferred_cancel_next;
		
		callback_list<function_callback_link5> *chain;
		
		mutex registration_mutex;
	};
	
	/** \cond NEVER */
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
	typename Context, void (*function)(Context, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5), void (*_release)(Context)>
	class function_link5 : public function_callback_link5<Arg1, Arg2, Arg3, Arg4, Arg5> {
	public:
		inline function_link5(Context _context) throw()
			: context(_context)
		{}
		virtual ~function_link5(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) throw()
		{(*function)(context, arg1, arg2, arg3, arg4, arg5);}
	private:
		Context context;
		virtual void cancelled(void) throw()
		{(*_release)(context);}
	};
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5), void (Obj::*_release)(void)>
	class obj_link5 : public function_callback_link5<Arg1, Arg2, Arg3, Arg4, Arg5> {
	public:
		inline obj_link5(Obj *instance ) throw()
			: i(instance)
		{}
		virtual ~obj_link5(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) throw()
		{(i->*function)(arg1, arg2, arg3, arg4, arg5);}
	private:
		Obj *i;
		virtual void cancelled(void) throw()
		{(i->*_release)();}
	};
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5)>
	class refobj_link5 : public function_callback_link5<Arg1, Arg2, Arg3, Arg4, Arg5> {
	public:
		inline refobj_link5(tscb::ref<Obj> instance ) throw()
			: i(tscb::ref_transfer<Obj>(instance))
		{}
		virtual ~refobj_link5(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) throw()
		{(i->*function)(arg1, arg2, arg3, arg4, arg5);}
	private:
		tscb::ref<Obj> i;
		virtual void cancelled(void) throw()
		{i=0;}
	};
	
	/** \endcond */
	
	/**
		\brief Chain of callback functions with 5 arguments
	*/
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
	class callback_chain5 : public callback_list<function_callback_link5<Arg1, Arg2, Arg3, Arg4, Arg5> > {
	public:
		typedef function_callback_link5<Arg1, Arg2, Arg3, Arg4, Arg5> link_type;
		typedef callback_list<link_type> parent_type;
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Context, void (*function)(Context, Arg1, Arg2, Arg3, Arg4, Arg5), void (*release)(Context)>
		ref_transfer<callback_link> connect(Context context) throw(std::bad_alloc)
		{
			link_type *l=
				new function_link5<Arg1, Arg2, Arg3, Arg4, Arg5, Context, function, release>(context);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2, Arg3, Arg4, Arg5), void(Obj::*release)(void)>
		ref_transfer<callback_link> connect(Obj *o) throw(std::bad_alloc)
		{
			link_type *l=
				new obj_link5<Arg1, Arg2, Arg3, Arg4, Arg5, Obj, function, release>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel".
			
			The target object muss support reference counting through
			->pin() and ->release() member functions; ->pin() will
			be used to acquire a reference to the target object; ->release()
			will be called after the callback has been cancelled.
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2, Arg3, Arg4, Arg5)>
		ref_transfer<callback_link> ref_connect(ref<Obj> o) throw(std::bad_alloc)
		{
			link_type *l=
				new refobj_link5<Arg1, Arg2, Arg3, Arg4, Arg5, Obj, function>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		inline void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5)
		{
			parent_type::read_lock();
			link_type *l=parent_type::active;
			while(l) {
				data_dependence_memory_barrier();
				(*l)(arg1, arg2, arg3, arg4, arg5);
				l=l->active_next;
			}
			parent_type::read_unlock();
		}
	};
	
	/**************************************************************************/
	
	/**
		\brief Link to callback function with 6 arguments
	*/
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
	class function_callback_link6 : public callback_link {
	public:
		function_callback_link6(void) throw()
			: active_next(0), prev(0), next(0), chain(0)
		{}
		virtual ~function_callback_link6(void) throw()
		{}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) throw()=0;
		virtual void cancel(void) throw()
		{
			registration_mutex.lock();
			if (chain) chain->remove(this);
			else registration_mutex.unlock();
		}
		
		function_callback_link6 *active_next;
		function_callback_link6 *prev, *next;
		function_callback_link6 *deferred_cancel_next;
		
		callback_list<function_callback_link6> *chain;
		
		mutex registration_mutex;
	};
	
	/** \cond NEVER */
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
	typename Context, void (*function)(Context, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6), void (*_release)(Context)>
	class function_link6 : public function_callback_link6<Arg1, Arg2, Arg3, Arg4, Arg5, Arg6> {
	public:
		inline function_link6(Context _context) throw()
			: context(_context)
		{}
		virtual ~function_link6(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) throw()
		{(*function)(context, arg1, arg2, arg3, arg4, arg5, arg6);}
	private:
		Context context;
		virtual void cancelled(void) throw()
		{(*_release)(context);}
	};

	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6), void (Obj::*_release)(void)>
	class obj_link6 : public function_callback_link6<Arg1, Arg2, Arg3, Arg4, Arg5, Arg6> {
	public:
		inline obj_link6(Obj *instance ) throw()
			: i(instance)
		{}
		virtual ~obj_link6(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) throw()
		{(i->*function)(arg1, arg2, arg3, arg4, arg5, arg6);}
	private:
		Obj *i;
		virtual void cancelled(void) throw()
		{(i->*_release)();}
	};
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
	typename Obj, void (Obj::*function)(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6)>
	class refobj_link6 : public function_callback_link6<Arg1, Arg2, Arg3, Arg4, Arg5, Arg6> {
	public:
		inline refobj_link6(tscb::ref<Obj> instance ) throw()
			: i(tscb::ref_transfer<Obj>(instance))
		{}
		virtual ~refobj_link6(void) throw() {}
		virtual void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) throw()
		{(i->*function)(arg1, arg2, arg3, arg4, arg5, arg6);}
	private:
		tscb::ref<Obj> i;
		virtual void cancelled(void) throw()
		{i=0;}
	};
	
	/** \endcond */
	
	/**
		\brief Chain of callback functions with 6 arguments
	*/
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
	class callback_chain6 : public callback_list<function_callback_link6<Arg1, Arg2, Arg3, Arg4, Arg5, Arg6> > {
	public:
		typedef function_callback_link6<Arg1, Arg2, Arg3, Arg4, Arg5, Arg6> link_type;
		typedef callback_list<link_type> parent_type;
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Context, void (*function)(Context, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), void (*release)(Context)>
		ref_transfer<callback_link> connect(Context context) throw(std::bad_alloc)
		{
			link_type *l=
				new function_link6<Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Context, function, release>(context);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel"
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), void(Obj::*release)(void)>
		ref_transfer<callback_link> connect(Obj *o) throw(std::bad_alloc)
		{
			link_type *l=
				new obj_link6<Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Obj, function, release>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Append new callback function to the chain
			
			Appends a new callback function to the chain. It will
			be called whenever \ref operator() of the chain is invoked,
			until it is cancelled by calling
			\ref tscb::callback_link::cancel "callback_link::cancel".
			
			The target object muss support reference counting through
			->pin() and ->release() member functions; ->pin() will
			be used to acquire a reference to the target object; ->release()
			will be called after the callback has been cancelled.
		*/
		template<typename Obj, void(Obj::*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>
		ref_transfer<callback_link> ref_connect(ref<Obj> o) throw(std::bad_alloc)
		{
			link_type *l=
				new refobj_link6<Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Obj, function>(o);
			push_back(l);
			return l;
		}
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		inline void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6)
		{
			parent_type::read_lock();
			link_type *l=parent_type::active;
			while(l) {
				data_dependence_memory_barrier();
				(*l)(arg1, arg2, arg3, arg4, arg5, arg6);
				l=l->active_next;
			}
			parent_type::read_unlock();
		}
	};
	
	class none {};
	
	/**
		\brief Generic callback chain
		
		This class template can be used to implement thread-safe chains of
		callback functions; all functions must have matching signature
		(take argument of the types declared by the template parameters).
		The signature can be declared with up to 6 parameters, but
		may use less (every template parameter except for the first
		one is optional).
		
		You can use the \ref connect function to append new callback
		functions to the chain.
		
		See \ref callback_descr for a description of how to use this
		class template.
	*/
	template<typename Arg1, typename Arg2=none, typename Arg3=none, typename Arg4=none, typename Arg5=none, typename Arg6=none>
	class callback_chain : public callback_chain6<Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>
	{};
	
	/** \cond NEVER */
	
	template<typename Arg1>
	class callback_chain<Arg1, none, none, none, none, none> : public callback_chain1<Arg1>
	{};
	
	template<typename Arg1, typename Arg2>
	class callback_chain<Arg1, Arg2, none, none, none, none> : public callback_chain2<Arg1, Arg2>
	{};
	
	template<typename Arg1, typename Arg2, typename Arg3>
	class callback_chain<Arg1, Arg2, Arg3, none, none, none> : public callback_chain3<Arg1, Arg2, Arg3>
	{};
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4>
	class callback_chain<Arg1, Arg2, Arg3, Arg4, none, none> : public callback_chain4<Arg1, Arg2, Arg3, Arg4>
	{};
	
	template<typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
	class callback_chain<Arg1, Arg2, Arg3, Arg4, Arg5, none> : public callback_chain5<Arg1, Arg2, Arg3, Arg4, Arg5>
	{};
	
	/** \endcond */
}

#endif

