/* -*- C++ -*-
 * (c) 2006 Helge Bahmann <hcb@chaoticmind.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1.
 * Refer to the file "COPYING" for details.
 */

#ifndef __TSCB_ATOMIC_IA64_H
#define __TSCB_ATOMIC_IA64_H

namespace tscb {
	
	/** \cond NEVER */
	
	#warning Atomics an IA64 are buggy, but I don't know why; please help me fix it
	
	/* FIXME: provide pointer to relevant Intel doc; not yet sure if
	this works at all
	
	I *think* cmpxchg is the only way to do what I want on IA64
	*/
	
	class atomic {
	public:
		inline atomic(long initial=0) : value(initial) {}
		inline void operator++(void) {
			int oldval, newval, verify;
			do {
				oldval=value;
				newval=oldval+1;
				verify=cmpxchg(oldval, newval);
			} while(oldval!=verify);
		}
		inline void operator++(int) {
			int oldval, newval, verify;
			do {
				oldval=value;
				newval=oldval+1;
				verify=cmpxchg(oldval, newval);
			} while(oldval!=verify);
		}
		inline bool operator--(void) {
			int oldval, newval, verify;
			do {
				oldval=value;
				newval=oldval-1;
				verify=cmpxchg(oldval, newval);
			} while(oldval!=verify);
			return (bool)verify;
		}
		inline void operator--(int) {
			int oldval, newval, verify;
			do {
				oldval=value;
				newval=oldval-1;
				verify=cmpxchg(oldval, newval);
			} while(oldval!=verify);
		}
		inline bool inc_if_not_zero(void) {
			int oldval, newval, verify;
			do {
				oldval=value;
				if (!oldval) return false;
				newval=oldval+1;
				verify=cmpxchg(oldval, newval);
			} while(oldval!=verify);
			return true;
		}
		inline operator long(void) const {return value;}
		inline operator bool(void) const {return (bool)value;}
		inline bool operator==(long v) const {return value==v;}
		inline bool operator==(int v) const {return value==v;}
		inline bool operator!=(long v) const {return value!=v;}
		inline bool operator!=(int v) const {return value!=v;}
		inline void operator=(long n) {value=n;}
	private:
		inline int cmpxchg(int oldval, int newval)
		{
			int result;
			__asm__ __volatile__(
				"mov ar.ccv=%1;;\n"
				"cmpxchg4.acq %0=[%2],%3,ar.ccv\n"
				: "=r"(result) : "rO"(oldval), "r"(&value), "r"(newval)
			);
			return result;
		}
		volatile int value;
	};
	
	inline void memory_barrier(void)
	{
		/* hm, I don't know how to insert a memory barrier on ia64 -- yet... */
		__asm__ __volatile__ ("" ::: "memory");
	}
	
	inline void data_dependence_memory_barrier(void)
	{
	}
	
	/** \endcond */
	
}

#endif
