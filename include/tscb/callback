/* -*- C++ -*-
 * (c) 2006 Helge Bahmann <hcb@chaoticmind.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1.
 * Refer to the file "COPYING" for details.
 */

#ifndef __TSCB_CALLBACK_H
#define __TSCB_CALLBACK_H

/**
	\page callback_descr Generic callbacks
	
	The \ref tscb::callback_chain "callback_chain" ... template class provides
	a generic callback mechanism. It allows one object
	(the "sender") to notify an arbitray number of other objects
	(the "receivers") of events by calling specified functions.
	
	The template can be instantiated with at least one and up
	to six template arguments; they allow to customize the signature of the
	callback functions to match the intended use case.
	
	\section callback_declaration Declaration of callback chains
	
	Callback chains are declared as global or member variables; the
	template argument defines the signature of the callback
	functions:
	
	\code
		class MyClass {
		public:
			// will report old and new value to callbacks
			tscb::callback_chain<void (int, int)> onValueChange;
			
			void setValue(int newval);
		private:
			int value;
		}
	\endcode
	
	\section callback_issue Issuing callbacks
	
	Callback chain objects (as declared in the previous example) provide
	an overloaded () operator which will call all callback functions
	registered with this callback chain:
	
	\code
		void MyClass::setValue(int newval)
		{
			int oldval=value;
			value=newval;
			// notify all registered callbacks
			onValueChange(oldval, newval);
		}
	\endcode
	
	The overloaded () operator expects exactly the number and type
	of arguments as were used when the callback chain was declared.
	
	\section callback_register Registration for callbacks
	
	Callback chains provide the \ref tscb::callback_chain::connect "connect"
	template member functions to allow receivers to add a callback
	function to the chain. They can be used in the following fashion:
	
	\code
		class MyObserver {
		public:
			MyObserver(MyClass *c)
			{
				c->onValueChange.connect(boost::bind(&MyObserver::notify_change, this, _1, _2));
			}
		protected:
			void notify_change(int oldval, int newval)
			{
				printf("Value changed from %d to %d!\n", oldval, newval);
			}
		};
	\endcode
	
	In the previous example, the <TT>notify_change</TT> method of the
	corresponding <TT>MyObserver</TT> object would be called
	whenever the callback chain is being activated
	(see section \ref callback_issue above). Note the the
	function object created via <TT>boost::bind</TT> will be
	destroyed as soon as the callback is cancelled (see section \ref callback_cookies below).
	
	The same technique can be used to bind "free" functions:
	
	\code
		char *msg="Incredible!";
		
		void notify_change(char *ctx, int oldval, int newval)
		{
			printf("%s Value changed from %d to %d!\n", ctx, oldval, newval);
		}
		
		int main(void)
		{
			MyObject obj;
			obj.onValueChange.connect(boost::bind(notify_change, msg, _1, _2));
			obj.setValue(42);
		}
	\endcode
	
	Like in the previous example, the function <TT>notify_change</TT>
	will be called whenever the callback chain is being activated.
	
	\section callback_cookies Callback link handles
	
	The
	\ref tscb::callback_chain::connect "connect"
	return a reference to a callback link object that represents the
	connection between the callback service provider and the receiver. The
	return value can be stored by the caller:
	
	\code
		tscb::callback link;
		link=c->onValueChange.connect(boost::bind(&MyObserver::notify_change, this, _1, _2));
	\endcode
	
	The link object can later be used to cancel the
	callback:
	
	\code
		link->cancel();
	\endcode
	
	The callback function will not be invoked subsequently; the data associated
	with the function object will be released as soon as it is guaranteed that
	the callback function cannot be called again (e.g. from other threads).
	This is useful e.g. if <TT>boost::shared_ptr</TT> is used to assist in
	tracking the lifetime objects:
	
	\code
		tscb::callback link;
		boost::shared_ptr<MyObserver> obj(new MyObserver);
		link=c->onValueChange.connect(boost::bind(&MyObserver::notify_change)
			boost::shared_ptr(obj), _1, _2));
	\endcode
	
	In this case, a <TT>boost::shared_ptr</TT> instance is kept for as long as
	the callback can be activated -- thus the object will not be deallocated
	until it is guaranteed that the callback cannot be delivered any longer.
	
	\section Performance
	
	The synchronization mechanism used to protect the integrity of the
	callback chains is \ref tscb::deferred_rwlock. Thus overhead
	incurred by the synchronization mechanism has to be paid for callback
	chains as well.
	
	The implementation assumes that callback processing (in contrast
	to callback registration/cancellation) is the fast path
	and has been optimized to this end. The performance characteristics
	are thus:
	
	<UL>
		<LI>
			process callbacks: O(number_of_registered_callbacks)
		</LI>
		<LI>
			cancel callback: O(1) (if there is no contention, i.e.
			the chain is not being traversed while cancelling callbacks)
		</LI>
		<LI>
			cancel callback: O(numer_of_cancels^2) (if there is contention,
			i.e. the chain is being traversed while cancelling callbacks)
		</LI>
	</UL>
	
	Some measurement were made to estimate the number of clock cycles
	it takes to call an empty function which takes a single integer parameter:
	
	<TABLE>
		<TR><TH>call type</TH><TH>Motorola PPC7455</TH><TH>Intel Pentium III SSE</TH><TH>AMD Athlon</TH></TR>
		<TR><TD>direct method call (non-virtual)</TD><TD>8</TD><TD>8</TD><TD>7</TD></TR>
		<TR><TD>indirect method call (non-virtual)</TD><TD>15</TD><TD>12</TD><TD>10</TD></TR>
		<TR><TD>callback chain, 1 callback</TD><TD>131</TD><TD>151</TD><TD>99</TD></TR>
		<TR><TD>callback chain, 2 callbacks</TD><TD>166</TD><TD>180</TD><TD>122</TD></TR>
		<TR><TD>callback chain, 3 callbacks</TD><TD>192</TD><TD>207</TD><TD>142</TD></TR>
	</TABLE>
*/

#include <stdexcept>

#include <boost/intrusive_ptr.hpp>
#include <boost/function.hpp>

#include <tscb/thread>
#include <tscb/deferred>
#include <tscb/compiler>

namespace tscb {
	
	/**
		\brief Abstract base of all callback links
		
		This object represents the link between a sender/caller, from
		which notification is requested, to a reciever/callee, to which
		notification is to be delivered. It is an abstract base class
		for all different kinds of links established through the various
		notification interfaces (callback_chains, file or timer events).
	*/
	class callback_link {
	public:
		inline callback_link(void) throw() : refcount(1) {}
		virtual ~callback_link(void) throw();
		/**
			\brief Break the link
			
			Calling this function will break the notification link. It will
			usually cease notifications to be delivered some time after this
			function has returned. The exact semantic guarantee is:
			
			<UL>
				<LI>
					no notification will be delivered within the same thread
					that has called \ref cancel after \ref cancel has
					returned (i.e. within the same thread, \ref cancel
					is synchronous)
				</LI>
				<LI>
					notifications in other threads may be delivered after
					\ref cancel has returned in one thread, but only
					for events that occured before \ref cancel has returned
					(i.e. for other threads, cancellation is asynchronous).
				</LI>
			</UL>
			
			The weak synchronicity guarantee allows implementations that
			provide excellent concurrency. Furthermore it allows
			\ref cancel to be called from arbitrary contexts: from within
			the callback to be cancelled, from different threads etc. It
			is guaranteed to be deadlock free.
			
		*/
		virtual void cancel(void) throw()=0;
		
		/** \internal \brief Increase reference count */
		inline void pin(void) throw() {refcount++;}
		/** \internal \brief Decrease reference count */
		inline void release(void) throw() {if (!--refcount) delete this;}
		
	private:
#ifdef _LIBTSCB_CALLBACK_UNITTESTS
	public:
#endif
		atomic refcount;
	};
	
	static inline void intrusive_ptr_add_ref(callback_link *t) throw()
	{
		t->pin();
	}
	
	static inline void intrusive_ptr_release(callback_link *t) throw()
	{
		t->release();
	}
	
	/**
		\brief Reference to callback link.
		
		Every other callback link implemented in this library can be
		downcast to this type.
	*/
	typedef boost::intrusive_ptr<callback_link> link;
	
	template<typename Signature> class function_callback_link;
	template<typename Signature> class callback_chain;
	
	/**
		\brief Generic callback link
		
		This object represents the link between a sender/caller, from
		which notification is requested, to a reciever/callee, to which
		notification is to be delivered. It is used for "generic" callbacks,
		i.e. those registered with a \ref callback_chain.
		
		See \ref callback_descr for usage.
	*/
	template<typename Signature>
	class function_callback_link : public callback_link {
	public:
		function_callback_link(const boost::function<Signature> &_target) throw(std::bad_alloc)
			: target(_target), active_next(0), prev(0), next(0), chain(0)
		{}
		virtual ~function_callback_link(void) throw()
		{}
		virtual void cancel(void) throw()
		{
			registration_mutex.lock();
			if (chain) chain->remove(this);
			else registration_mutex.unlock();
		}
		/** \internal \brief Called after cancellation to destroy the function object */
		void cancelled(void) throw()
		{
			target=0;
		}
		
		/** \internal \brief Functional to be called on activation */
		boost::function<Signature> target;
		
		/** \internal \brief Next element in list of active callbacks */
		function_callback_link *active_next;
		/** \internal \brief Previous element in list */
		function_callback_link *prev;
		/** \internal \brief Next element in list */
		function_callback_link *next;
		/** \internal \brief Next element in list of callbacks with pending cancellation */
		function_callback_link *deferred_cancel_next;
		
		/** \internal \brief Chain to which this object is registered */
		callback_chain<Signature> *chain;
		
		/** \internal \brief Serialize deregistration */
		mutex registration_mutex;
	};
	
	/**
		\brief Generic notifier chain
		
		This object allows interested receivers to register themselves
		for notification, and it allows a sender to deliver notification
		to all registered receivers.
		
		See \ref callback_descr for usage.
	*/
	template<typename Signature>
	class callback_chain {
	public:
		typedef function_callback_link<Signature> link_type;
		
		/**
			\brief Add callback to chain
			
			\param function
				Function to be called when chain is activated
		*/
		boost::intrusive_ptr<link_type>
		connect(const boost::function<Signature> &function) throw(std::bad_alloc)
		{
			link_type *l=new link_type(function);
			push_back(l);
			return l;
		}
		
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		inline void operator()(void)
		{
			read_lock();
			link_type *l=active;
			while(l) {
				data_dependence_memory_barrier();
				l->target();
				l=l->active_next;
			}
			read_unlock();
		}
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		template<typename Arg1>
		inline void operator()(Arg1 arg1)
		{
			read_lock();
			link_type *l=active;
			while(l) {
				data_dependence_memory_barrier();
				l->target(arg1);
				l=l->active_next;
			}
			read_unlock();
		}
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		template<typename Arg1, typename Arg2>
		inline void operator()(Arg1 arg1, Arg2 arg2)
		{
			read_lock();
			link_type *l=active;
			while(l) {
				data_dependence_memory_barrier();
				l->target(arg1, arg2);
				l=l->active_next;
			}
			read_unlock();
		}
		/**
			\brief Call all callback functions registered with the chain
			
			Calls all callback functions registered trough \ref connect
			with the given arguments.
		*/
		template<typename Arg1, typename Arg2, typename Arg3>
		inline void operator()(Arg1 arg1, Arg2 arg2, Arg3 arg3)
		{
			read_lock();
			link_type *l=active;
			while(l) {
				data_dependence_memory_barrier();
				l->target(arg1, arg2, arg3);
				l=l->active_next;
			}
			read_unlock();
		}
		
		callback_chain(void) throw()
			: active(0), first(0), last(0), deferred_cancel(0)
		{}
		
		~callback_chain(void) throw()
		{
			/* there is no point in locking here... if the object
			is destroyed and anyone is trying to add a callback
			at this moment we are hosed anyways */
			
			/* but we can protect against anyone *removing*
			callbacks concurrently */
			
			while(guard.read_lock()) synchronize();
			while (active) active->cancel();
			if (guard.read_unlock()) {
				/* the above cancel operations will cause synchronization
				to be performed at the next possible point in time; if
				there is no concurrent cancellation, this is now */
				synchronize();
			} else {
				/* this can only happen if some callback link was
				cancelled while this object is being destroyed; in
				that case we have to suspend the thread that is destroying
				the object until we are certain that synchronization has
				been performed */
				
				guard.write_lock_sync();
				synchronize();
				
				/* note that synchronize implicitly calls sync_finished,
				which is equivalent to write_unlock_sync for deferrable_rwlocks */
			}
		}
		
		void push_back(link_type *l) throw()
		{
			l->registration_mutex.lock();
			bool sync=guard.write_lock_async();
			
			l->next=0;
			l->prev=last;
			
			l->active_next=0;
			
			/* prevent traversal of chain from seeing "incomplete" entries */
			memory_barrier();
			
			/* add element to active list; find all elements that have been removed
			from the full list and thus terminate the active list; point them to
			the newly-added element */
			
			link_type *tmp=last;
			while(true) {
				if (!tmp) {
					if (!active) active=l;
					break;
				}
				if (tmp->active_next) break;
				tmp->active_next=l;
				tmp=tmp->prev;
			}
			
			/* insert into list of all elements*/
			if (last) last->next=l;
			else first=l;
			last=l;
			
			l->chain=this;
			
			l->registration_mutex.unlock();
			
			if (sync) synchronize();
			else guard.write_unlock_async();
		}
		
		void remove(link_type *l) throw()
		{
			bool sync=guard.write_lock_async();
			if (l->chain==this) {
				/* remove element from active list; we have to make
				sure that all elements that pointed to "us" within
				the active chain now point to the following element,
				so this element is skipped from within the active chain */
				
				link_type *tmp=l->prev;
				while(true) {
					if (!tmp) {
						if (active==l) active=l->active_next;
						break;
					}
					if (tmp->active_next!=l) break;
					tmp->active_next=l->active_next;
					tmp=tmp->prev;
				}
				
				/* put on list of elements marked for deferred cancellation */
				l->deferred_cancel_next=deferred_cancel;
				deferred_cancel=l;
				
				/* remove pointer to chain, so a second call to ->cancel()
				will do nothing */
				l->chain=0;
			}
			
			l->registration_mutex.unlock();
			
			if (sync) synchronize();
			else guard.write_unlock_async();
		}
		
		void synchronize(void) throw()
		{
			link_type *do_cancel=deferred_cancel;
			
			/* first, "repair" the list structure by "correcting" all prev
			pointers */
			while(do_cancel) {
				/* we can now safely remove the elements from the list */
				if (do_cancel->prev) do_cancel->prev->next=do_cancel->next;
				else first=do_cancel->next;
				if (do_cancel->next) do_cancel->next->prev=do_cancel->prev;
				else last=do_cancel->prev;
				
				do_cancel=do_cancel->deferred_cancel_next;
			}
			
			/* now swap pointers while still under the lock; this is
			necessary to make sure that the destructor for each
			callback link object is called exactly once */
			do_cancel=deferred_cancel;
			deferred_cancel=0;
			guard.sync_finished();
			
			/* now we can release the callbacks, as we are sure that no one
			can "see" them anymore; the lock is dropped so side-effest
			of finalizing the links cannot cause deadlocks */
			
			while(do_cancel) {
				link_type *tmp=do_cancel->deferred_cancel_next;
				do_cancel->cancelled();
				do_cancel->release();
				do_cancel=tmp;
			}
		}
		
		inline void read_lock(void) throw()
		{
			while(guard.read_lock()) synchronize();
		}
		
		inline void read_unlock(void) throw()
		{
			if (guard.read_unlock()) synchronize();
		}
	protected:
		/* singly-linked list of active elements */
		link_type *active;
		
		/* thread synchronization */
		deferrable_rwlock guard;
		
		/* list of all elements in the chain, whether active or not */
		link_type *first, *last;
		
		/* singly-linked list of elements that have been removed from
		the active list, but are not yet removed from the full list
		and not been discarded yet*/
		link_type *deferred_cancel;
	};

}

#endif

