/* -*- C++ -*-
 * (c) 2006 Helge Bahmann <hcb@chaoticmind.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1.
 * Refer to the file "COPYING" for details.
 */

#ifndef __TSCB_LIST_H
#define __TSCB_LIST_H

/**
	\page list_descr Intrusive linked lists
	
	Template class for intrusive linked lists: \ref tscb::list "list"
*/

namespace tscb {
	
	/**
		\brief Intrusive linked list
		
		Provides the functionality of a doubly linked list; unlike STL
		lists, the list pointers have to be member variables of the
		linked objects; the names of the member variables can be
		customized through the <TT>prev</TT> and <TT>next</TT>
		template parameters.
		
		Integrating the list pointers into the objects themselves has
		several advantages:
		
		<UL>
			<LI>
				no separate memory management for the list headers required;
				this means:
				<UL>
					<LI>
						none of the list operations throws any exceptions
					</LI>
					<LI>
						all operations are real-time safe (as they do not
						block on memory management)
					</LI>
				</UL>
			</LI>
			<LI>
				objects can be members of multiple lists; in STL this
				is only possible by storing pointers (instead of the
				objects themselves)
			</LI>
		</UL>
	*/
	template <typename T, T *T::*prev = &T::prev, T *T::*next = &T::next>
	class list {
	public:
		/**
			\brief List iterator
		*/
		class iterator {
		public:
			inline iterator(void) : ptr(0) {}
			inline const iterator &operator++(void) {ptr=(*ptr).*next; return *this;}
			inline iterator operator++(int) {iterator tmp=*this; ptr=(*ptr).*next; return tmp;}
			inline const iterator &operator--(void) {if (ptr) ptr=(*ptr).*prev; else ptr=l->last; return *this;}
			inline iterator operator--(int) {iterator tmp=*this; if (ptr) ptr=(*ptr).*prev; else ptr=l->last; return tmp;}
			inline operator T *(void) const {return ptr;}
			inline T* operator->(void) const {return ptr;}
			inline bool operator==(const iterator &i) const {return ptr==i.ptr;}
			inline bool operator!=(const iterator &i) const {return ptr!=i.ptr;}
		private:
			T *ptr;
			list *l;
			inline iterator(T *p, list *_l) : ptr(p) , l(_l) {}
			friend class list;
		};
		inline list(void) : first(0), last(0) {}
		inline void push_back(T *obj)
		{
			if (last) (*last).*next=obj; else first=obj;
			(*obj).*prev=last;
			(*obj).*next=0;
			last=obj;
		}
		inline void push_front(T *obj)
		{
			if (first) (*first).*prev=obj; else last=obj;
			(*obj).*prev=0;
			(*obj).*next=first;
			first=obj;
		}
		inline void remove(T *obj)
		{
			if ((*obj).*prev) *((*obj).*prev).*next=(*obj).*next;
			else first=(*obj).*next;
			if ((*obj).*next) *((*obj).*next).*prev=(*obj).*prev;
			else last=(*obj).*prev;
		}
		inline void join_front(list &l)
		{
			if (l.last) l.last->*next=first;
			
			if (first) first->*prev=l.last;
			else last=l.last;
			
			first=l.first;
			
			l.first=0;
			l.last=0;
		}
		inline void join_back(list &l)
		{
			if (l.first) l.first->*prev=last;
			
			if (last) last->*next=l.first;
			else first=l.first;
			
			last=l.last;
			
			l.first=0;
			l.last=0;
		}
		
		inline iterator begin(void) {return iterator(first, this);}
		inline iterator end(void) {return iterator(0, this);}
	private:
		T *first, *last;
		friend class iterator;
	};
	
}

#endif
