/* -*- C++ -*-
 * (c) 2006 Helge Bahmann <hcb@chaoticmind.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1.
 * Refer to the file "COPYING" for details.
 */

#ifndef __TSCB_REF_H
#define __TSCB_REF_H

/**
	\page ref_descr Reference counting
	
	\section ref_overview Overview
	
	Reference-counting is a technique for tracking the lifetime of objects;
	it is especially useful in multi-threaded applications as it allows to
	acces objects from multiple threads in parallel without excessive locking.
	
	A counter is embedded into each object; this counter represents the number
	of times this object is "in use" or "potentially in use"; it has to
	be increased every time a new "reference" to this object is created
	somewhere (thereby creating a new path through which this object could be
	"in use"), and decreased everytime such a reference is dropped; a zero
	value of the reference count indicates that the object can no longer be
	accessed (usually it means that it can immediately be destroyed).
	
	If the reference counter is managed incorrectly this can have drastic
	consequences, as it means that objects can become either "immortal"
	(if the reference counter is unable to drop to zero); or it may be destroyed
	prematurely (if the reference counter drops to zero although the
	object might still be in use) which usually results in a crash or
	random memory corruption. 
	
	The template classes and functions provided here are designed to assist in
	maintaining a correct reference count. They are also desgined in a way that
	does not <I>force</I> the programmer to use them if he does not want to,
	even though he is using classes and functions that rely on these primitives.
	They are <I>not</I> designed to make it impossible for someone to
	shoot himself in the foot, like some other reference-counting implementations
	try to do by making it "syntactically impossible to use the primitives
	in incorrect ways". This decision is deliberate to make interoperability
	with other frameworks easier.
	
	\section ref_simple_counter Simple Reference-Counted objects
	
	For an object to participate in reference counting, it needs an
	internal counter. This counter can be an ordinary integer variable, but
	for multi-threaded applications it is essential that this variable can
	be incremented and decremented atomically, so that two threads trying to
	manipulate the reference counter concurrently do not interfer badly. It
	is therefore recommended to use the \ref tscb::atomic "atomic" data type
	discussed \ref atomic_descr "here".
	
	The counter is never accessed directly, instead two helper functions
	<CODE>pin</CODE> and <CODE>release</CODE> have to be provided. To understand
	the naming of the functions imagine the object as a highly volatile
	animal you intend to study; to make sure it does not go away when
	you intend to look at it you have to <CODE>pin</CODE> it to the table
	using a needle, and when you are done you pull the needle back out and
	thereby <CODE>release</CODE> the critter; when the last needle has been
	pulled out, it can escape anytime it wishes. The whole complexity
	in reference counting is tracking of the "ownership" of the needles,
	even though the needles itself are never stored, but only their number.
	
	Thus, to create an object that supports reference counting, simply
	declare two public member functions, <CODE>pin</CODE> and
	<CODE>release</CODE> that perform the appropriate actions. For reasons
	outlined \ref ref_new "below" it is a good idea to initialize the reference
	counter to 1 for all newly created objects:
	
	\code
		class MyReferenceCountedObject {
		public:
			MyReferenceCountedObject(void) : reference_counter(1) {}
			~MyReferenceCountedObject(void) {assert(reference_counter==0);}
			
			inline void pin(void) {++reference_counter;}
			inline void release(void) {if (!--reference_counter) delete this;}
		private:
			tscb::atomic reference_counter;
		};
	\endcode
	
	That's it basically. Note that the <CODE>release</CODE> function is also
	responsible for object disposure, in this case the object is
	destroyed using the <CODE>delete</CODE> operator, but it is possible
	to perform other actions (like, for example, recycling it for future use,
	or putting it onto a list for deferred deallocation; see
	\ref ref_deferred "below".
	
	It might be a good idea to mark the counting functions <CODE>const</CODE>
	and the reference counter itself <CODE>mutable</CODE> so that you can obtain
	new references to an object that you are not allowed to modify (fortunately
	enough <CODE>delete</CODE> is allowed on a <CODE>const</CODE> object):
	
	\code
		class MyReferenceCountedObject {
		public:
			MyReferenceCountedObject(void) : reference_counter(1) {}
			~MyReferenceCountedObject(void) {assert(reference_counter==0);}
			
			inline void pin(void) const {++reference_counter;}
			inline void release(void) const {if (!--reference_counter) delete this;}
		private:
			mutable tscb::atomic reference_counter;
		};
	\endcode
	
	\section ref_automatic_refence Automatic Reference Management
	
	You can, in theory, manually manage the reference counter by explicitly
	calling <CODE>pin</CODE> and <CODE>release</CODE> every time you create
	or drop a reference to an object. However this is inconvenient and
	error-prone, so the <CODE>ref</CODE> class template is here to automate
	this task. The <CODE>ref</CODE> class essentially represents a "needle"
	as explained above.
	
	It is used in a way very similiar to ordinary pointers:
	
	\code
		tscb::ref<MyClass> r;
		r=other_reference_or_pointer_to_an_object; // create a new reference, i.e. implicitly call ->pin()
		r->myMemberFunction();
		r->myMemberVariable=42;
		r=0; // drop refernce, i.e. implicitly call ->release()
	\endcode
	
	Using <CODE>ref</CODE> exclusively throughout the program in this way
	will ensure that the reference counter does always have the correct
	value. The <CODE>ref</CODE> template class has the following semantics:
	
	<UL>
		<LI>
			The constructor of \ref tscb::ref will grab a new reference to the
			object pointed at by a previously existing \ref tscb::ref or pointer
			(so the first two lines of the above example could
			be simplified to <CODE>ref&lt;MyClass&gt; r(other_reference_or_pointer_to_an_object);</CODE>).
		</LI>
		<LI>
			Assignment to \ref tscb::ref through the = operator from another <CODE>ref</CODE>
			or a pointer will drop the refernce to the object previously pointed at
			and grab a reference to the new object
		</LI>
		<LI>
			The value of 0 (zero) may be assigned to the object to indicate that the
			reference is currently "pointing nowhere". This is the default value
			for \ref tscb::ref objects constructed through the default constructor.
		</LI>
		<LI>
			The destructor will drop the reference to the object currently being pointed
			at.
		</LI>
	</UL>
	
	<B>Important:</B> \ref tscb::ref does not make any atomicity guarantees
	about its own state; it is a programming error to assign to a \ref tscb::ref
	in one thread while concurrently reading its value in another thread
	(reading from two different threads is ok OTOH). To provide synchronization
	while manipulating a \ref tscb::ref, use mutexes, or see the section
	on <CODE>atomic_ref</CODE> in the section "Advanced: Lockless references"
	\ref ref_lockless "below".
	
	\section ref_manual_assign_unassign Manually (un)assigning references
	
	Sometimes it is required to manually push something that "already has
	a reference sticked on it" into a <CODE>ref</CODE>, or get something out
	of a <CODE>ref</CODE> without dropping the reference counter. Consider
	the following example:
	
	\code
		MyClass *aPointer=some_object_reference;
		aPointer->pin(); // manually bump reference counter
		...
		// now we want to transfer the reference from the pointer to a ref
		tscb::ref<MyClass> r=aPointer; // will implicitly call ->pin()
		aPointer->release(); // remove extraneous reference
		aPointer=0; // pointer is no longer needed
	\endcode
	
	In the above example there is an extraneous <CODE>pin</CODE>/<CODE>release</CODE>
	cycle that could be optimized away (note that because the counter itself is
	usually not an "ordinary" integer but an atomic counter variable instead,
	this operation is considerably more expensive than a simple addition/subtraction
	on some architectures). For this purpose, the <CODE>assign</CODE> function
	allows to assign to a <CODE>ref</CODE> object without implicitly
	bumping the reference counter (under the assumption that the programmer
	has already explicitly done so):
	
	\code
		MyClass *aPointer=some_object_reference;
		aPointer->pin(); // manually bump reference counter
		...
		// now we want to transfer the reference from the pointer to a ref
		tscb::ref<MyClass> r;
		r.assign(aPointer); // assign without bumping reference counter
		aPointer=0; // pointer is no longer needed
	\endcode
	
	In a similiar spirit, it is sometimes desirable to get an object out of
	a <CODE>ref</CODE> without dropping the reference counter, e.g.:
	
	\code
		ref<MyClass> r=pointer_to_an_object;
		MyClass *aPointer=r; // want to get the reference out
		aPointer->pin(); // create a new reference
		r=0; // will implicitly call release
	\endcode
	
	The superfluous <CODE>pin</CODE>/<CODE>release</CODE> cycle can be optimized
	away using <CODE>unassign</CODE>:
	
	\code
		ref<MyClass> r=pointer_to_an_object;
		aPointer=r.unassign(); // r now points nowhere (to 0), but counter is not decreased
		...
		aPointer->release(); // manually release reference obtained above
	\endcode
	
	<B>Important</B>: 1. <CODE>assign</CODE> will still drop the reference
	to the object that was previously referenced. 2. <CODE>release</CODE> will
	still be called on this object if a new object is assigned to the
	<CODE>ref</CODE>. 3. after calling <CODE>unassign</CODE> the reference
	will point to 0
	
	\section ref_new Referencing objects instantiated by new
	
	Sometimes during instantiation of a class it is necessary to insert a
	reference to the newly created object from inside the constructor. Consider
	the following example:
	
	\code
		class MyClass;
		
		mutex protect_youngest;
		tscb::ref<MyClass> youngest;
		
		class MyClass {
		public:
			MyClass(void) {protect_youngest.lock(); youngest=this; protect_youngest.unlock();}
			~MyClass(void) {assert(reference_counter==0);}
			inline void pin(void) const {++refernce_counter;}
			inline void release(void) const {if !(--reference_counter) delete this;}
		private:
			tscb::atomic reference_counter;
		};
	\endcode

	Now two threads might go about concurrently instantiating an object of this
	class and assigning to a <CODE>ref</CODE>:
	
	<TABLE BORDER="0" WIDTH="100%">
		<TR>
			<TD>Thread 1</TD><TD>Thread 2</TD>
		</TR>
		<TR>
			<TD><CODE>ref&lt;MyClass&gt; a=<B>new</B> MyClass;</CODE></TD>
			<TD><CODE>ref&lt;MyClass&gt; b=<B>new</B> MyClass;</CODE></TD>
		</TR>
	</TABLE>
	
	What might happen in detail is the following:
	
	<TABLE BORDER="1" WIDTH="100%">
		<TR>
			<TD WIDTH="50%">Thread 1</TD><TD WIDTH="50%">Thread 2</TD>
		</TR>
		<TR>
			<TD>calls <CODE><B>new</B> MyClass;</CODE></TD><TD></TD>
		</TR>
		<TR>
			<TD></TD><TD>calls <CODE><B>new</B> MyClass;</CODE></TD>
		</TR>
		<TR>
			<TD>object A is created; refcount=0</TD><TD></TD>
		</TR>
		<TR>
			<TD></TD><TD>object B is created; refcount=0</TD>
		</TR>
		<TR>
			<TD><CODE>youngest=A;</CODE> refcount(A)=1</TD><TD></TD>
		</TR>
		<TR>
			<TD></TD><TD><CODE>youngest=B;</CODE> refcount(B)=1, but
			refcount of A is reduced to 0 because previously <CODE>youngest</CODE>
			has pointed to A but no longer does; object A is destroyed immediately</TD>
		</TR>
		<TR>
			<TD><CODE><B>new</B></CODE> returns; assignment to
			a increases reference count of object A to 1, but A has
			been deleted already. WHOOPS!</TD><TD></TD>
		</TR>
		<TR>
			<TD></TD><TD><CODE><B>new</B></CODE> returns; assignment to b
			increases reference count of object B to 2</TD>
		</TR>
	</TABLE>
	
	To remedy this problem, newly created objects should <I>always</I> start
	out with a reference count of 1! This ensures that the object is alive
	after the <CODE><B>new</B></CODE> operator returns -- but it has
	the unfortunate side-effect that the following code is <I>not</I> correct:
	
	\code
		tscb::ref<MyClass> r=new MyClass;
	\endcode
	
	Assigning to <CODE>r</CODE> via the = operator will bump the reference counter,
	so that the reference counter is now 2, not 1. The solution to this
	problem is to use the <CODE>assign</CODE> method instead for
	new objects (optionally it would be possible to assign using the = operator
	and after that manually call <CODE>release</CODE>, but this is not
	any more readable):
	
	\code
		tscb::ref<MyClas> r.assign(new MyClass);
	\endcode
	
	\section ref_ref_transfer Transferring reference ownership
	
	Transferring references across function calls is a problem that is similiar
	in nature to instantiating objects via <CODE><B>new</B></CODE>: there
	needs to be a mechanism to make sure that objects returned to the caller
	have a positive reference count. It is possible to pass around temporary
	<CODE>ref</CODE> objects as function arguments or function return values,
	but this will result in a <CODE>pin</CODE>/<CODE>release</CODE> cycle
	that can be optimized away.
	
	The <CODE>ref_transfer</CODE> template class is intended to be used
	for this purpose. Metaphorically it allows to transfer
	"ownership of an existing needle" instead of "plucking in a new needle
	and ripping out a previous one", and it is this transfer of "needle
	ownership" that is represented by the class.
	
	To understand what the class does consider the following simple transfer
	of reference ownership between two <CODE>ref</CODE> objects:
	
	\code
		tscb::ref<MyClass> r1, r2;
		...
		r2=r1;
		r1=0;
	\endcode
	
	This will needlessly call <CODE>pin</CODE> and <CODE>release</CODE>, so it
	is better to instead write
	
	\code
		tscb::ref<MyClass> r1, r2;
		...
		r2.assign(r1.unassign());
	\endcode
	
	However this looks a bit strange at first sight; more importantly the calling order
	of <CODE>assign</CODE> and <CODE>unassign</CODE> has to be in exactly
	this order -- which poses a problem for function return values (because
	<CODE>unassign</CODE> has to be called inside the function), so the
	"right" way to do it would be:
	
	\code
		tscb::ref<MyClass> r1, r2;
		...
		MyClass *tmp=r1.unassign();
		r2.assign(tmp);
	\endcode
	
	This is awkward to write, so <CODE>ref_transfer</CODE> can help to
	automate all of the cross-assignment:
	
	\code
		tscb::ref<MyClass> r1, r2;
		...
		r2=tscb::ref_transfer<MyClass>(r1);
	\endcode
	
	The way it works is the following:
	
	<UL>
		<LI>
			Constructing a <CODE>ref_transfer</CODE> object from a <CODE>ref</CODE> object
			will take a temporary pointer to the object and call <CODE>unassign</CODE> on
			the <CODE>ref</CODE> object
		</LI>
		<LI>
			Constructing a <CODE>ref</CODE> object or assigning to a <CODE>ref</CODE>
			object from a <CODE>ref_transfer</CODE> object is equivalent to calling
			<CODE>assign</CODE>
		<LI>
			(Constructing a <CODE>ref_transfer</CODE> object from a pointer will
			simply copy the pointer to without calling <CODE>pin</CODE> for this
			object)
		</LI>
		<LI>
			(Assigning to a pointer from a <CODE>ref_transfer</CODE> object will
			simply make the pointer point to the object, without any call
			to <CODE>pin</CODE> or <CODE>release</CODE>)
		</LI>
	</UL>
	
	Thus functions that wish to transfer reference to an object to the caller
	should return a <CODE>ref_transfer</CODE> object, and the following
	code will work correctly without <I>any</I> superfluous call to either
	<CODE>pin</CODE> or <CODE>release</CODE>:
	
	\code
		tscb::ref_transfer<MyClass> my_function(void)
		{
			tscb::ref<MyClass> tmp.assign(new MyClass);
			... // do something with the object
			return tmp;
		}
		...
		main()
		{
			tscb::ref<MyClass> r=my_function();
		}
	\endcode
	
	As a bonus, the caller has the option of assigning the return value
	to a pointer instead of a \ref tscb::ref object. The \ref tscb::ref_transfer
	class works correctly in this case as well, but as usual the caller
	has to remember to discard the refernce by calling ->release() manually.
	This mechanism is implemented as a conversion operator to pointer
	type of the \ref tscb::ref_transfer class, so the gotcha is that
	you have to remember at all times that every use of the
	class that explicitly or implicitly converts it to a pointer will
	complete the transfer of reference.
	
	\section ref_deferred Advanced: Deferred deallocation
	
	TO BE WRITTEN
	
	\section ref_lockless Advanced: Lockless containers
	
	TO BE WRITTEN
*/

#include <tscb/atomic>

namespace tscb {
	
	/** \cond NEVER */
	template<class T>
	class default_counter_functor {
	public:
		inline void pin(T *t) throw() {t->pin();}
		inline void release(T *t) throw() {t->release();}
	};
	/** \endcond */
	
	template<typename T, typename C=default_counter_functor<T> > class ref;
	template<typename T, typename C=default_counter_functor<T> > class ref_transfer;
	
	/**
		\brief reference to a ref-counted object
		
		\param T
		The type of object that will be referenced
		
		\param C
		The functor object that will be used to manipulate the reference counter
		of the object; this parameter can be omitted, in this case 
		default_counter_functor will be used, which simply calls ->pin()
		and ->release() methods of the object, respectively
		
		ref objects are used to point to reference-counted objects (called
		"target objects" in the following). They can be used
		used much like pointers, i.e. it is possible to
		use the * and -> operators on ref objects to access the target
		objects member variables and methods. Like a pointer, a ref may either
		point nowhere (to "zero"), or to a live object.
		
		Additionally, ref objects help to maintain the correct value of the
		reference counter; the reference counter of any object will be
		increased by one for each ref pointing to this object, and will be
		decreased accordingly for each ref that ceases to point to this
		object.
	*/
	template<typename T, typename C>
	class ref {
	public:
		/**
			\brief default initialization with zero pointer
			
			Initialize the ref to point "nowhere".
		*/
		inline ref(void) throw() : ptr(0) {}
		
		/**
			\brief release reference on destruction
			
			Destroying a ref object will cause the reference to the target
			object to be dropped
		*/
		inline ~ref(void) throw() {if (ptr) c.release(ptr); }
		
		/**
			\brief initialize ref pointing to an object	
			
			This will increase the reference counter of the target object
		*/
		inline ref(T *p) throw() : ptr(p) {if (ptr) c.pin(p);}

		/**
			\brief point reference to different object
			
			This will increase the reference counter of the new target object
			and decrease the reference counter of the old target object
		*/
		inline void operator=(T *p) throw()
		{if (ptr) c.release(ptr); ptr=p; if (ptr) c.pin(ptr);}
	
		/**
			\brief initialize ref pointing to an object	
			
			This will increase the reference counter of the target object;
			separate declaration for copy constructor because existance
			of copy constructor is checked before attempting template
			specialization
		*/
		inline ref(const ref &p) throw() : ptr(p.ptr) {if (ptr) c.pin(ptr);}
		
		/**
			\brief point reference to different object
			
			This will increase the reference counter of the new target object
			and decrease the reference counter of the old target object;
			separate declaration for copy operator, see above
		*/
		inline void operator=(const ref &p) throw()
		{if (ptr) c.release(ptr); ptr=p.ptr; if(ptr) c.pin(ptr);}
		
		/**
			\brief initialize ref pointing to an object	
			
			This will increase the reference counter of the target object
		*/
		template<typename X, typename Y>
		inline ref(const ref<X, Y> &p) throw() : ptr(p.ptr) {c.pin(ptr);}
		
		/**
			\brief point reference to different object
			
			This will increase the reference counter of the new target object
			and decrease the reference counter of the old target object
		*/
		template<typename X, typename Y>
		inline void operator=(const ref<X, Y> &p) throw()
		{if (ptr) c.release(ptr); ptr=p.ptr; if(ptr) c.pin(ptr);}
		
		/* special assignment from transfer objects: object ownership is
		conveyed through ref_transfer/ref_return object, so MUST NOT
		increment ref counter */
		/**
			\brief initialize ref pointing to an object, take over reference
			
			This will take over the reference transferred using a
			\ref ref_transfer object; the reference counter of the
			new target object is <I>not</I>
			increased, as ownership of the object is transferred using
			the transfer proxy object. However, the reference counter
			of the previous target object is decreased.
		*/
		template<typename X, typename Y>
		inline ref(const ref_transfer<X, Y> &r) {ptr=r.unassign();}
		
		/**
			\brief point reference to different object, take over reference
			
			This will take over the reference transferred using a
			\ref ref_transfer object; the reference counter of the
			new target object is <I>not</I>
			increased, as ownership of the object is transferred using
			the transfer proxy object. However, the reference counter
			of the previous target object is decreased.
		*/
		inline void operator=(const ref_transfer<T> &r) throw()
		{if (ptr) c.release(ptr); ptr=r.unassign();}
		
		/**
			\brief point reference to different object, take over reference
			
			This will take over the reference transferred using a
			\ref ref_transfer object; the reference counter of the
			new target object is <I>not</I>
			increased, as ownership of the object is transferred using
			the transfer proxy object. However, the reference counter
			of the previous target object is decreased.
		*/
		template<typename X>
		inline void operator=(const ref_transfer<X> &r) throw()
		{if (ptr) c.release(ptr); ptr=r.unassign();}
		
		/* comparison and testing for 0 */
		/**
			\brief test for equality with a pointer
		*/
		inline bool operator==(T *p) const throw() {return p==ptr;}
		/**
			\brief test for zero
			
			This operator allows the ref object to be used exactly as a pointer
			in if statements.
		*/
		inline operator bool(void) const throw() {return bool(ptr);}
		
		/* cast to ordinary pointer and dereference member */
		/**
			\brief dereference member of target object
			
			Allows to access member variables and methods of the target
			object
		*/
		inline T *operator->(void) const throw() {return ptr;}
		/**
			\brief dereference target object
			
			Allows to access the target object exactly as if the
			reference were an ordinary pointer type.
		*/
		inline operator T *(void) const throw() {return ptr;}
		
		/* internal functions to transfer references directly without
		modifying the reference count; this assumes the caller knows
		what he is doing */
		/**
			\brief assign object without bumping reference counter
			
			This will point the ref to a new target object, but the
			reference counter of the target object is <I>not</I>
			increased (but the reference counter of the old target object
			is decreased). This is useful to transfer a reference into
			a ref object when the caller knows what he is doing.
		*/
		inline void assign(T *p) throw() {if (ptr) c.release(ptr); ptr=p;}
		/**
			\brief unassign object without dropping reference counter
			
			This will retrieve the object pointed at by the ref and
			assign 0 to the ref <I>without</I> dropping the reference counter
			of the previous target object. This is useful to get an object
			out of a ref without modification of the reference counter; it
			assumes the caller knows what he is doing.
			
			Returns the previous target object.
		*/
		inline T *unassign(void) throw() {T *tmp=ptr; ptr=0; return tmp;}
		
		/**
			\brief dynamic cast to different type of object
			
			This will attempt to cast the given object to a different
			type of object, using RTTI (run-time type information).
			The call returns either a new reference to the given
			object, or 0 if the cast failed.
		*/
		template <typename X>
		ref_transfer<X> cast_dynamic(void) const throw()
		{
			X *x=dynamic_cast<X *>(ptr);
			if (x) {
				x->pin();
				return x;
			} else return 0;
		}
		
		T *ptr;
		C c;
	};
	
	/**
		\brief reference transfer class
		
		takes over reference from one ref object to another
		ref object without temporarily bumping the reference counter in
		between
	*/
	template<typename T, typename C>
	class ref_transfer {
	public:
		/**
			\brief take over reference from a ref object
			
			This constructor takes over the reference from a ref object
			(i.e. the ref object afterwards points to 0) without modifying
			the reference counter; the ref_transfer object can then be
			used to assign this acquired reference to a different ref object.
		*/
		ref_transfer(ref<T, C>& r) throw() {ptr=r.unassign();}
		/**
			\brief take over reference from a ref_transfer object
			
			This constructor takes over the reference from a ref_transfer
			object; this just prolongs the chain and is equivalent to directly
			assigning to this ref where the original ref got its object from.
		*/
		ref_transfer(ref_transfer& r) throw() {ptr=r.unassign();}
		/**
			\brief take over reference from a pointer
			
			This constructor takes over the reference from a pointer;
			the caller has to make sure that there was actually a reference
			acquired for this pointer (most likely by calling \c pin on
			the target object).
		*/
		ref_transfer(T* r) throw() {ptr=r;}
		/**
			\brief release reference on destruction
			
			Destroying a ref_transfer object will cause the reference to
			the target object to be dropped; to avoid releasing the
			reference, it is sufficient to assign from the ref_transfer
			to a ref object, or use the \ref unassign method.
		*/
		~ref_transfer(void) throw() {if (ptr) c.release(ptr);}
	
		template<typename X, typename Y>
		ref_transfer(ref<X, Y>& r) throw() {ptr=r; r.unassign();}
		template<typename X, typename Y>
		ref_transfer(const ref_transfer<X, Y>& r) throw() {ptr=r.unassign();}
		
		/**
			\brief take over reference into a pointer
			
			Normally \c ref_transfer objects should only be assigned
			to \c ref objects; this will ensure that the transfer of
			reference ownership completes correctly and the reference counter
			is managed accordingly.
			
			However in some cases it is desirable to assign to a pointer
			instead; in that case it is necessary to get the reference out
			of the \c ref_transfer object in the same way as \c unassign
			does for \ref tscb::ref objects (to avoid destroying the referenced
			object when the \c ref_transfer object is destroyed).
			
			This is performed by the \c unassign function, which will make
			sure that the reference is not dropped when the \c ref_transfer
			object is destroyed, and return a pointer to the referenced
			object at the same time.
		*/
		inline T *unassign(void) const throw() {T *tmp=ptr; ptr=0; return tmp;}
		
		/**
			\brief take over reference into a pointer
			
			The same as \ref unassign.
		*/
		inline operator T *(void) throw() {return unassign();}
	private:
		C c;
		mutable T *ptr;
		friend class ref<T>;
	};
	
};

#endif
